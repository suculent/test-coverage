/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/DemoServer.swift:
    1|       |//
    2|       |//  DemoServer.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|      0|public func demoServer(_ publicDir: String) -> HttpServer {
   12|      0|    
   13|      0|    print(publicDir)
   14|      0|    
   15|      0|    let server = HttpServer()
   16|      0|    
   17|      0|    server["/public/:path"] = shareFilesFromDirectory(publicDir)
   18|      0|
   19|      0|    server["/files/:path"] = directoryBrowser("/")
   20|      0|
   21|      0|    server["/"] = scopes {
   22|      0|        html {
   23|      0|            body {
   24|      0|                ul(server.routes) { service in
   25|      0|                    li {
   26|      0|                        a { href = service; inner = service }
   27|      0|                    }
   28|      0|                }
   29|      0|            }
   30|      0|        }
   31|      0|    }
   32|      0|    
   33|      0|    server["/magic"] = { .ok(.html("You asked for " + $0.path)) }
   34|      0|    
   35|      0|    server["/test/:param1/:param2"] = { r in
   36|      0|        scopes {
   37|      0|            html {
   38|      0|                body {
   39|      0|                    h3 { inner = "Address: \(r.address ?? "unknown")" }
   40|      0|                    h3 { inner = "Url: \(r.path)" }
   41|      0|                    h3 { inner = "Method: \(r.method)" }
   42|      0|                    
   43|      0|                    h3 { inner = "Query:" }
   44|      0|                    
   45|      0|                    table(r.queryParams) { param in
   46|      0|                        tr {
   47|      0|                            td { inner = param.0 }
   48|      0|                            td { inner = param.1 }
   49|      0|                        }
   50|      0|                    }
   51|      0|                    
   52|      0|                    h3 { inner = "Headers:" }
   53|      0|                    
   54|      0|                    table(r.headers) { header in
   55|      0|                        tr {
   56|      0|                            td { inner = header.0 }
   57|      0|                            td { inner = header.1 }
   58|      0|                        }
   59|      0|                    }
   60|      0|                    
   61|      0|                    h3 { inner = "Route params:" }
   62|      0|                    
   63|      0|                    table(r.params) { param in
   64|      0|                        tr {
   65|      0|                            td { inner = param.0 }
   66|      0|                            td { inner = param.1 }
   67|      0|                        }
   68|      0|                    }
   69|      0|                }
   70|      0|            }
   71|      0|        }(r)
   72|      0|    }
   73|      0|    
   74|      0|    server.GET["/upload"] = scopes {
   75|      0|        html {
   76|      0|            body {
   77|      0|                form {
   78|      0|                    method = "POST"
   79|      0|                    action = "/upload"
   80|      0|                    enctype = "multipart/form-data"
   81|      0|                    
   82|      0|                    input { name = "my_file1"; type = "file" }
   83|      0|                    input { name = "my_file2"; type = "file" }
   84|      0|                    input { name = "my_file3"; type = "file" }
   85|      0|                    
   86|      0|                    button {
   87|      0|                        type = "submit"
   88|      0|                        inner = "Upload"
   89|      0|                    }
   90|      0|                }
   91|      0|            }
   92|      0|        }
   93|      0|    }
   94|      0|    
   95|      0|    server.POST["/upload"] = { r in
   96|      0|        var response = ""
   97|      0|        for multipart in r.parseMultiPartFormData() {
   98|      0|            guard let name = multipart.name, let fileName = multipart.fileName else { continue }
   99|      0|            response += "Name: \(name) File name: \(fileName) Size: \(multipart.body.count)<br>"
  100|      0|        }
  101|      0|        return HttpResponse.ok(.html(response))
  102|      0|    }
  103|      0|    
  104|      0|    server.GET["/login"] = scopes {
  105|      0|        html {
  106|      0|            head {
  107|      0|                script { src = "http://cdn.staticfile.org/jquery/2.1.4/jquery.min.js" }
  108|      0|                stylesheet { href = "http://cdn.staticfile.org/twitter-bootstrap/3.3.0/css/bootstrap.min.css" }
  109|      0|            }
  110|      0|            body {
  111|      0|                h3 { inner = "Sign In" }
  112|      0|                
  113|      0|                form {
  114|      0|                    method = "POST"
  115|      0|                    action = "/login"
  116|      0|                    
  117|      0|                    fieldset {
  118|      0|                        input { placeholder = "E-mail"; name = "email"; type = "email"; autofocus = "" }
  119|      0|                        input { placeholder = "Password"; name = "password"; type = "password"; autofocus = "" }
  120|      0|                        a {
  121|      0|                            href = "/login"
  122|      0|                            button {
  123|      0|                                type = "submit"
  124|      0|                                inner = "Login"
  125|      0|                            }
  126|      0|                        }
  127|      0|                    }
  128|      0|                    
  129|      0|                }
  130|      0|                javascript {
  131|      0|                    src = "http://cdn.staticfile.org/twitter-bootstrap/3.3.0/js/bootstrap.min.js"
  132|      0|                }
  133|      0|            }
  134|      0|        }
  135|      0|    }
  136|      0|    
  137|      0|    server.POST["/login"] = { r in
  138|      0|        let formFields = r.parseUrlencodedForm()
  139|      0|        return HttpResponse.ok(.html(formFields.map({ "\($0.0) = \($0.1)" }).joined(separator: "<br>")))
  140|      0|    }
  141|      0|    
  142|      0|    server["/demo"] = scopes {
  143|      0|        html {
  144|      0|            body {
  145|      0|                center {
  146|      0|                    h2 { inner = "Hello Swift" }
  147|      0|                    img { src = "https://devimages.apple.com.edgekey.net/swift/images/swift-hero_2x.png" }
  148|      0|                }
  149|      0|            }
  150|      0|        }
  151|      0|    }
  152|      0|    
  153|      0|    server["/raw"] = { r in
  154|      0|        return HttpResponse.raw(200, "OK", ["XXX-Custom-Header": "value"], { try $0.write([UInt8]("test".utf8)) })
  155|      0|    }
  156|      0|    
  157|      0|    server["/redirect"] = { r in
  158|      0|        return .movedPermanently("http://www.google.com")
  159|      0|    }
  160|      0|
  161|      0|    server["/long"] = { r in
  162|      0|        var longResponse = ""
  163|      0|        for k in 0..<1000 { longResponse += "(\(k)),->" }
  164|      0|        return .ok(.html(longResponse))
  165|      0|    }
  166|      0|    
  167|      0|    server["/wildcard/*/test/*/:param"] = { r in
  168|      0|        return .ok(.html(r.path))
  169|      0|    }
  170|      0|    
  171|      0|    server["/stream"] = { r in
  172|      0|        return HttpResponse.raw(200, "OK", nil, { w in
  173|      0|            for i in 0...100 {
  174|      0|                try w.write([UInt8]("[chunk \(i)]".utf8))
  175|      0|            }
  176|      0|        })
  177|      0|    }
  178|      0|    
  179|      0|    server["/websocket-echo"] = websocket(text: { (session, text) in
  180|      0|        session.writeText(text)
  181|      0|    }, binary: { (session, binary) in
  182|      0|        session.writeBinary(binary)
  183|      0|    }, pong: { (session, pong) in
  184|      0|        // Got a pong frame
  185|      0|    }, connected: { (session) in
  186|      0|        // New client connected
  187|      0|    }, disconnected: { (session) in
  188|      0|        // Client disconnected
  189|      0|    })
  190|      0|    
  191|      0|    server.notFoundHandler = { r in
  192|      0|        return .movedPermanently("https://github.com/404")
  193|      0|    }
  194|      0|    
  195|      0|    server.middleware.append { r in
  196|      0|        print("Middleware: \(r.address ?? "unknown address") -> \(r.method) -> \(r.path)")
  197|      0|        return nil
  198|      0|    }
  199|      0|    
  200|      0|    return server
  201|      0|}
  202|       |    

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Errno.swift:
    1|       |//
    2|       |//  Errno.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright © 2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class Errno {
   11|       |    
   12|      0|    public class func description() -> String {
   13|      0|        return String(cString: UnsafePointer(strerror(errno)))
   14|      0|    }
   15|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Files.swift:
    1|       |//
    2|       |//  HttpHandlers+Files.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|      0|public func shareFile(_ path: String) -> ((HttpRequest) -> HttpResponse) {
   11|      0|    return { r in
   12|      0|        if let file = try? path.openForReading() {
   13|      0|            return .raw(200, "OK", [:], { writer in
   14|      0|                try? writer.write(file)
   15|      0|                file.close()
   16|      0|            })
   17|      0|        }
   18|      0|        return .notFound
   19|      0|    }
   20|      0|}
   21|       |
   22|      0|public func shareFilesFromDirectory(_ directoryPath: String, defaults: [String] = ["index.html", "default.html"]) -> ((HttpRequest) -> HttpResponse) {
   23|      0|    return { r in
   24|      0|        guard let fileRelativePath = r.params.first else {
   25|      0|            return .notFound
   26|      0|        }
   27|      0|        if fileRelativePath.value.isEmpty {
   28|      0|            for path in defaults {
   29|      0|                if let file = try? (directoryPath + String.pathSeparator + path).openForReading() {
   30|      0|                    return .raw(200, "OK", [:], { writer in
   31|      0|                        try? writer.write(file)
   32|      0|                        file.close()
   33|      0|                    })
   34|      0|                }
   35|      0|            }
   36|      0|        }
   37|      0|        if let file = try? (directoryPath + String.pathSeparator + fileRelativePath.value).openForReading() {
   38|      0|            let mimeType = fileRelativePath.value.mimeType();
   39|      0|            
   40|      0|            return .raw(200, "OK", ["Content-Type": mimeType], { writer in
   41|      0|                try? writer.write(file)
   42|      0|                file.close()
   43|      0|            })
   44|      0|        }
   45|      0|        return .notFound
   46|      0|    }
   47|      0|}
   48|       |
   49|      0|public func directoryBrowser(_ dir: String) -> ((HttpRequest) -> HttpResponse) {
   50|      0|    return { r in
   51|      0|        guard let (_, value) = r.params.first else {
   52|      0|            return HttpResponse.notFound
   53|      0|        }
   54|      0|        let filePath = dir + String.pathSeparator + value
   55|      0|        do {
   56|      0|            guard try filePath.exists() else {
   57|      0|                return .notFound
   58|      0|            }
   59|      0|            if try filePath.directory() {
   60|      0|                var files = try filePath.files()
   61|      0|                files.sort(by: {$0.lowercased() < $1.lowercased()})
   62|      0|                return scopes {
   63|      0|                    html {
   64|      0|                        body {
   65|      0|                            table(files) { file in
   66|      0|                                tr {
   67|      0|                                    td {
   68|      0|                                        a {
   69|      0|                                            href = r.path + "/" + file
   70|      0|                                            inner = file
   71|      0|                                        }
   72|      0|                                    }
   73|      0|                                }
   74|      0|                            }
   75|      0|                        }
   76|      0|                    }
   77|      0|                    }(r)
   78|      0|            } else {
   79|      0|                guard let file = try? filePath.openForReading() else {
   80|      0|                    return .notFound
   81|      0|                }
   82|      0|                return .raw(200, "OK", [:], { writer in
   83|      0|                    try? writer.write(file)
   84|      0|                    file.close()
   85|      0|                })
   86|      0|            }
   87|      0|        } catch {
   88|      0|            return HttpResponse.internalServerError
   89|      0|        }
   90|      0|    }
   91|      0|}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpParser.swift:
    1|       |//
    2|       |//  HttpParser.swift
    3|       |//  Swifter
    4|       |// 
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |enum HttpParserError: Error {
   11|       |    case InvalidStatusLine(String)
   12|       |}
   13|       |
   14|       |public class HttpParser {
   15|       |    
   16|      0|    public init() { }
   17|       |    
   18|      0|    public func readHttpRequest(_ socket: Socket) throws -> HttpRequest {
   19|      0|        let statusLine = try socket.readLine()
   20|      0|        let statusLineTokens = statusLine.components(separatedBy: " ")
   21|      0|        if statusLineTokens.count < 3 {
   22|      0|            throw HttpParserError.InvalidStatusLine(statusLine)
   23|      0|        }
   24|      0|        let request = HttpRequest()
   25|      0|        request.method = statusLineTokens[0]
   26|      0|        request.path = statusLineTokens[1]
   27|      0|        request.queryParams = extractQueryParams(request.path)
   28|      0|        request.headers = try readHeaders(socket)
   29|      0|        if let contentLength = request.headers["content-length"], let contentLengthValue = Int(contentLength) {
   30|      0|            request.body = try readBody(socket, size: contentLengthValue)
   31|      0|        }
   32|      0|        return request
   33|      0|    }
   34|       |    
   35|      0|    private func extractQueryParams(_ url: String) -> [(String, String)] {
   36|      0|        guard let questionMark = url.index(of: "?") else {
   37|      0|            return []
   38|      0|        }
   39|      0|        let queryStart = url.index(after: questionMark)
   40|      0|
   41|      0|        guard url.endIndex > queryStart else { return [] }
   42|      0|        let query = String(url[queryStart..<url.endIndex])
   43|      0|
   44|      0|        return query.components(separatedBy: "&")
   45|      0|            .reduce([(String, String)]()) { (c, s) -> [(String, String)] in
   46|      0|                guard let nameEndIndex = s.index(of: "=") else {
   47|      0|                    return c
   48|      0|                }
   49|      0|                guard let name = String(s[s.startIndex..<nameEndIndex]).removingPercentEncoding else {
   50|      0|                    return c
   51|      0|                }
   52|      0|                let valueStartIndex = s.index(nameEndIndex, offsetBy: 1)
   53|      0|                guard valueStartIndex < s.endIndex else {
   54|      0|                    return c + [(name, "")]
   55|      0|                }
   56|      0|                guard let value = String(s[valueStartIndex..<s.endIndex]).removingPercentEncoding else {
   57|      0|                    return c + [(name, "")]
   58|      0|                }
   59|      0|                return c + [(name, value)]
   60|      0|        }
   61|      0|    }
   62|       |    
   63|      0|    private func readBody(_ socket: Socket, size: Int) throws -> [UInt8] {
   64|      0|        var body = [UInt8]()
   65|      0|        for _ in 0..<size { body.append(try socket.read()) }
   66|      0|        return body
   67|      0|    }
   68|       |    
   69|      0|    private func readHeaders(_ socket: Socket) throws -> [String: String] {
   70|      0|        var headers = [String: String]()
   71|      0|        while case let headerLine = try socket.readLine() , !headerLine.isEmpty {
   72|      0|            let headerTokens = headerLine.split(separator: ":", maxSplits: 1, omittingEmptySubsequences: true).map(String.init)
   73|      0|            if let name = headerTokens.first, let value = headerTokens.last {
   74|      0|                headers[name.lowercased()] = value.trimmingCharacters(in: .whitespaces)
   75|      0|            }
   76|      0|        }
   77|      0|        return headers
   78|      0|    }
   79|       |    
   80|      0|    func supportsKeepAlive(_ headers: [String: String]) -> Bool {
   81|      0|        if let value = headers["connection"] {
   82|      0|            return "keep-alive" == value.trimmingCharacters(in: .whitespaces)
   83|      0|        }
   84|      0|        return false
   85|      0|    }
   86|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpRequest.swift:
    1|       |//
    2|       |//  HttpRequest.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class HttpRequest {
   11|       |    
   12|       |    public var path: String = ""
   13|       |    public var queryParams: [(String, String)] = []
   14|       |    public var method: String = ""
   15|       |    public var headers: [String: String] = [:]
   16|       |    public var body: [UInt8] = []
   17|       |    public var address: String? = ""
   18|       |    public var params: [String: String] = [:]
   19|       |    
   20|      0|    public init() {}
   21|       |    
   22|      0|    public func hasTokenForHeader(_ headerName: String, token: String) -> Bool {
   23|      0|        guard let headerValue = headers[headerName] else {
   24|      0|            return false
   25|      0|        }
   26|      0|        return headerValue.components(separatedBy: ",").filter({ $0.trimmingCharacters(in: .whitespaces).lowercased() == token }).count > 0
   27|      0|    }
   28|       |    
   29|      0|    public func parseUrlencodedForm() -> [(String, String)] {
   30|      0|        guard let contentTypeHeader = headers["content-type"] else {
   31|      0|            return []
   32|      0|        }
   33|      0|        let contentTypeHeaderTokens = contentTypeHeader.components(separatedBy: ";").map { $0.trimmingCharacters(in: .whitespaces) }
   34|      0|        guard let contentType = contentTypeHeaderTokens.first, contentType == "application/x-www-form-urlencoded" else {
   35|      0|            return []
   36|      0|        }
   37|      0|        guard let utf8String = String(bytes: body, encoding: .utf8) else {
   38|      0|            // Consider to throw an exception here (examine the encoding from headers).
   39|      0|            return []
   40|      0|        }
   41|      0|        return utf8String.components(separatedBy: "&").map { param -> (String, String) in
   42|      0|            let tokens = param.components(separatedBy: "=")
   43|      0|            if let name = tokens.first?.removingPercentEncoding, let value = tokens.last?.removingPercentEncoding, tokens.count == 2 {
   44|      0|                return (name.replacingOccurrences(of: "+", with: " "),
   45|      0|                        value.replacingOccurrences(of: "+", with: " "))
   46|      0|            }
   47|      0|            return ("","")
   48|      0|        }
   49|      0|    }
   50|       |    
   51|       |    public struct MultiPart {
   52|       |        
   53|       |        public let headers: [String: String]
   54|       |        public let body: [UInt8]
   55|       |        
   56|      0|        public var name: String? {
   57|      0|            return valueFor("content-disposition", parameter: "name")?.unquote()
   58|      0|        }
   59|       |        
   60|      0|        public var fileName: String? {
   61|      0|            return valueFor("content-disposition", parameter: "filename")?.unquote()
   62|      0|        }
   63|       |        
   64|       |        private func valueFor(_ headerName: String, parameter: String) -> String? {
   65|      0|            return headers.reduce([String]()) { (combined, header: (key: String, value: String)) -> [String] in
   66|      0|                guard header.key == headerName else {
   67|      0|                    return combined
   68|      0|                }
   69|      0|                let headerValueParams = header.value.components(separatedBy: ";").map { $0.trimmingCharacters(in: .whitespaces) }
   70|      0|                return headerValueParams.reduce(combined, { (results, token) -> [String] in
   71|      0|                    let parameterTokens = token.components(separatedBy: "=")
   72|      0|                    if parameterTokens.first == parameter, let value = parameterTokens.last {
   73|      0|                        return results + [value]
   74|      0|                    }
   75|      0|                    return results
   76|      0|                })
   77|      0|                }.first
   78|       |        }
   79|       |    }
   80|       |    
   81|      0|    public func parseMultiPartFormData() -> [MultiPart] {
   82|      0|        guard let contentTypeHeader = headers["content-type"] else {
   83|      0|            return []
   84|      0|        }
   85|      0|        let contentTypeHeaderTokens = contentTypeHeader.components(separatedBy: ";").map { $0.trimmingCharacters(in: .whitespaces) }
   86|      0|        guard let contentType = contentTypeHeaderTokens.first, contentType == "multipart/form-data" else {
   87|      0|            return []
   88|      0|        }
   89|      0|        var boundary: String? = nil
   90|      0|        contentTypeHeaderTokens.forEach({
   91|      0|            let tokens = $0.components(separatedBy: "=")
   92|      0|            if let key = tokens.first, key == "boundary" && tokens.count == 2 {
   93|      0|                boundary = tokens.last
   94|      0|            }
   95|      0|        })
   96|      0|        if let boundary = boundary, boundary.utf8.count > 0 {
   97|      0|            return parseMultiPartFormData(body, boundary: "--\(boundary)")
   98|      0|        }
   99|      0|        return []
  100|      0|    }
  101|       |    
  102|      0|    private func parseMultiPartFormData(_ data: [UInt8], boundary: String) -> [MultiPart] {
  103|      0|        var generator = data.makeIterator()
  104|      0|        var result = [MultiPart]()
  105|      0|        while let part = nextMultiPart(&generator, boundary: boundary, isFirst: result.isEmpty) {
  106|      0|            result.append(part)
  107|      0|        }
  108|      0|        return result
  109|      0|    }
  110|       |    
  111|      0|    private func nextMultiPart(_ generator: inout IndexingIterator<[UInt8]>, boundary: String, isFirst: Bool) -> MultiPart? {
  112|      0|        if isFirst {
  113|      0|            guard nextUTF8MultiPartLine(&generator) == boundary else {
  114|      0|                return nil
  115|      0|            }
  116|      0|        } else {
  117|      0|            let /* ignore */ _ = nextUTF8MultiPartLine(&generator)
  118|      0|        }
  119|      0|        var headers = [String: String]()
  120|      0|        while let line = nextUTF8MultiPartLine(&generator), !line.isEmpty {
  121|      0|            let tokens = line.components(separatedBy: ":")
  122|      0|            if let name = tokens.first, let value = tokens.last, tokens.count == 2 {
  123|      0|                headers[name.lowercased()] = value.trimmingCharacters(in: .whitespaces)
  124|      0|            }
  125|      0|        }
  126|      0|        guard let body = nextMultiPartBody(&generator, boundary: boundary) else {
  127|      0|            return nil
  128|      0|        }
  129|      0|        return MultiPart(headers: headers, body: body)
  130|      0|    }
  131|       |    
  132|      0|    private func nextUTF8MultiPartLine(_ generator: inout IndexingIterator<[UInt8]>) -> String? {
  133|      0|        var temp = [UInt8]()
  134|      0|        while let value = generator.next() {
  135|      0|            if value > HttpRequest.CR {
  136|      0|                temp.append(value)
  137|      0|            }
  138|      0|            if value == HttpRequest.NL {
  139|      0|                break
  140|      0|            }
  141|      0|        }
  142|      0|        return String(bytes: temp, encoding: String.Encoding.utf8)
  143|      0|    }
  144|       |    
  145|       |    static let CR = UInt8(13)
  146|       |    static let NL = UInt8(10)
  147|       |    
  148|      0|    private func nextMultiPartBody(_ generator: inout IndexingIterator<[UInt8]>, boundary: String) -> [UInt8]? {
  149|      0|        var body = [UInt8]()
  150|      0|        let boundaryArray = [UInt8](boundary.utf8)
  151|      0|        var matchOffset = 0;
  152|      0|        while let x = generator.next() {
  153|      0|            matchOffset = ( x == boundaryArray[matchOffset] ? matchOffset + 1 : 0 )
  154|      0|            body.append(x)
  155|      0|            if matchOffset == boundaryArray.count {
  156|      0|                #if swift(>=4.2)
  157|      0|                body.removeSubrange(body.count-matchOffset ..< body.count)
  158|      0|                #else
  159|      0|                body.removeSubrange(CountableRange<Int>(body.count-matchOffset ..< body.count))
  160|      0|                #endif
  161|      0|                if body.last == HttpRequest.NL {
  162|      0|                    body.removeLast()
  163|      0|                    if body.last == HttpRequest.CR {
  164|      0|                        body.removeLast()
  165|      0|                    }
  166|      0|                }
  167|      0|                return body
  168|      0|            }
  169|      0|        }
  170|      0|        return nil
  171|      0|    }
  172|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpResponse.swift:
    1|       |//
    2|       |//  HttpResponse.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public enum SerializationError: Error {
   11|       |    case invalidObject
   12|       |    case notSupported
   13|       |}
   14|       |
   15|       |public protocol HttpResponseBodyWriter {
   16|       |    func write(_ file: String.File) throws
   17|       |    func write(_ data: [UInt8]) throws
   18|       |    func write(_ data: ArraySlice<UInt8>) throws
   19|       |    func write(_ data: NSData) throws
   20|       |    func write(_ data: Data) throws
   21|       |}
   22|       |
   23|       |public enum HttpResponseBody {
   24|       |    
   25|       |    case json(AnyObject)
   26|       |    case html(String)
   27|       |    case text(String)
   28|       |    case data(Data)
   29|       |    case custom(Any, (Any) throws -> String)
   30|       |    
   31|      0|    func content() -> (Int, ((HttpResponseBodyWriter) throws -> Void)?) {
   32|      0|        do {
   33|      0|            switch self {
   34|      0|            case .json(let object):
   35|      0|                #if os(Linux)
   36|      0|                    let data = [UInt8]("Not ready for Linux.".utf8)
   37|      0|                    return (data.count, {
   38|      0|                        try $0.write(data)
   39|      0|                    })
   40|      0|                #else
   41|      0|                    guard JSONSerialization.isValidJSONObject(object) else {
   42|      0|                        throw SerializationError.invalidObject
   43|      0|                    }
   44|      0|                    let data = try JSONSerialization.data(withJSONObject: object)
   45|      0|                    return (data.count, {
   46|      0|                        try $0.write(data)
   47|      0|                    })
   48|      0|                #endif
   49|      0|            case .text(let body):
   50|      0|                let data = [UInt8](body.utf8)
   51|      0|                return (data.count, {
   52|      0|                    try $0.write(data)
   53|      0|                })
   54|      0|            case .html(let body):
   55|      0|                let serialised = "<html><meta charset=\"UTF-8\"><body>\(body)</body></html>"
   56|      0|                let data = [UInt8](serialised.utf8)
   57|      0|                return (data.count, {
   58|      0|                    try $0.write(data)
   59|      0|                })
   60|      0|            case .data(let data):
   61|      0|                return (data.count, {
   62|      0|                    try $0.write(data)
   63|      0|                })
   64|      0|            case .custom(let object, let closure):
   65|      0|                let serialised = try closure(object)
   66|      0|                let data = [UInt8](serialised.utf8)
   67|      0|                return (data.count, {
   68|      0|                    try $0.write(data)
   69|      0|                })
   70|      0|            }
   71|      0|        } catch {
   72|      0|            let data = [UInt8]("Serialisation error: \(error)".utf8)
   73|      0|            return (data.count, {
   74|      0|                try $0.write(data)
   75|      0|            })
   76|      0|        }
   77|      0|    }
   78|       |}
   79|       |
   80|       |public enum HttpResponse {
   81|       |    
   82|       |    case switchProtocols([String: String], (Socket) -> Void)
   83|       |    case ok(HttpResponseBody), created, accepted
   84|       |    case movedPermanently(String)
   85|       |    case badRequest(HttpResponseBody?), unauthorized, forbidden, notFound
   86|       |    case internalServerError
   87|       |    case raw(Int, String, [String:String]?, ((HttpResponseBodyWriter) throws -> Void)? )
   88|       |
   89|      0|    func statusCode() -> Int {
   90|      0|        switch self {
   91|      0|        case .switchProtocols(_, _)   : return 101
   92|      0|        case .ok(_)                   : return 200
   93|      0|        case .created                 : return 201
   94|      0|        case .accepted                : return 202
   95|      0|        case .movedPermanently        : return 301
   96|      0|        case .badRequest(_)           : return 400
   97|      0|        case .unauthorized            : return 401
   98|      0|        case .forbidden               : return 403
   99|      0|        case .notFound                : return 404
  100|      0|        case .internalServerError     : return 500
  101|      0|        case .raw(let code, _ , _, _) : return code
  102|      0|        }
  103|      0|    }
  104|       |    
  105|      0|    func reasonPhrase() -> String {
  106|      0|        switch self {
  107|      0|        case .switchProtocols(_, _)    : return "Switching Protocols"
  108|      0|        case .ok(_)                    : return "OK"
  109|      0|        case .created                  : return "Created"
  110|      0|        case .accepted                 : return "Accepted"
  111|      0|        case .movedPermanently         : return "Moved Permanently"
  112|      0|        case .badRequest(_)            : return "Bad Request"
  113|      0|        case .unauthorized             : return "Unauthorized"
  114|      0|        case .forbidden                : return "Forbidden"
  115|      0|        case .notFound                 : return "Not Found"
  116|      0|        case .internalServerError      : return "Internal Server Error"
  117|      0|        case .raw(_, let phrase, _, _) : return phrase
  118|      0|        }
  119|      0|    }
  120|       |    
  121|      0|    func headers() -> [String: String] {
  122|      0|        var headers = ["Server" : "Swifter \(HttpServer.VERSION)"]
  123|      0|        switch self {
  124|      0|        case .switchProtocols(let switchHeaders, _):
  125|      0|            for (key, value) in switchHeaders {
  126|      0|                headers[key] = value
  127|      0|            }
  128|      0|        case .ok(let body):
  129|      0|            switch body {
  130|      0|            case .json(_)   : headers["Content-Type"] = "application/json"
  131|      0|            case .html(_)   : headers["Content-Type"] = "text/html"
  132|      0|            default:break
  133|      0|            }
  134|      0|        case .movedPermanently(let location):
  135|      0|            headers["Location"] = location
  136|      0|        case .raw(_, _, let rawHeaders, _):
  137|      0|            if let rawHeaders = rawHeaders {
  138|      0|                for (k, v) in rawHeaders {
  139|      0|                    headers.updateValue(v, forKey: k)
  140|      0|                }
  141|      0|            }
  142|      0|        default:break
  143|      0|        }
  144|      0|        return headers
  145|      0|    }
  146|       |    
  147|      0|    func content() -> (length: Int, write: ((HttpResponseBodyWriter) throws -> Void)?) {
  148|      0|        switch self {
  149|      0|        case .ok(let body)             : return body.content()
  150|      0|        case .badRequest(let body)     : return body?.content() ?? (-1, nil)
  151|      0|        case .raw(_, _, _, let writer) : return (-1, writer)
  152|      0|        default                        : return (-1, nil)
  153|      0|        }
  154|      0|    }
  155|       |    
  156|      0|    func socketSession() -> ((Socket) -> Void)?  {
  157|      0|        switch self {
  158|      0|        case .switchProtocols(_, let handler) : return handler
  159|      0|        default: return nil
  160|      0|        }
  161|      0|    }
  162|       |}
  163|       |
  164|       |/**
  165|       |    Makes it possible to compare handler responses with '==', but
  166|       |	ignores any associated values. This should generally be what
  167|       |	you want. E.g.:
  168|       |	
  169|       |    let resp = handler(updatedRequest)
  170|       |        if resp == .NotFound {
  171|       |        print("Client requested not found: \(request.url)")
  172|       |    }
  173|       |*/
  174|       |
  175|      0|func ==(inLeft: HttpResponse, inRight: HttpResponse) -> Bool {
  176|      0|    return inLeft.statusCode() == inRight.statusCode()
  177|      0|}
  178|       |

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpRouter.swift:
    1|       |//
    2|       |//  HttpRouter.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |open class HttpRouter {
   12|       |    
   13|      0|    public init() {
   14|      0|    }
   15|       |    
   16|       |    private class Node {
   17|       |        var nodes = [String: Node]()
   18|       |        var handler: ((HttpRequest) -> HttpResponse)? = nil
   19|       |    }
   20|       |    
   21|       |    private var rootNode = Node()
   22|       |
   23|      0|    public func routes() -> [String] {
   24|      0|        var routes = [String]()
   25|      0|        for (_, child) in rootNode.nodes {
   26|      0|            routes.append(contentsOf: routesForNode(child));
   27|      0|        }
   28|      0|        return routes
   29|      0|    }
   30|       |    
   31|      0|    private func routesForNode(_ node: Node, prefix: String = "") -> [String] {
   32|      0|        var result = [String]()
   33|      0|        if let _ = node.handler {
   34|      0|            result.append(prefix)
   35|      0|        }
   36|      0|        for (key, child) in node.nodes {
   37|      0|            result.append(contentsOf: routesForNode(child, prefix: prefix + "/" + key));
   38|      0|        }
   39|      0|        return result
   40|      0|    }
   41|       |    
   42|      0|    public func register(_ method: String?, path: String, handler: ((HttpRequest) -> HttpResponse)?) {
   43|      0|        var pathSegments = stripQuery(path).split("/")
   44|      0|        if let method = method {
   45|      0|            pathSegments.insert(method, at: 0)
   46|      0|        } else {
   47|      0|            pathSegments.insert("*", at: 0)
   48|      0|        }
   49|      0|        var pathSegmentsGenerator = pathSegments.makeIterator()
   50|      0|        inflate(&rootNode, generator: &pathSegmentsGenerator).handler = handler
   51|      0|    }
   52|       |    
   53|      0|    public func route(_ method: String?, path: String) -> ([String: String], (HttpRequest) -> HttpResponse)? {
   54|      0|        if let method = method {
   55|      0|            let pathSegments = (method + "/" + stripQuery(path)).split("/")
   56|      0|            var pathSegmentsGenerator = pathSegments.makeIterator()
   57|      0|            var params = [String:String]()
   58|      0|            if let handler = findHandler(&rootNode, params: &params, generator: &pathSegmentsGenerator) {
   59|      0|                return (params, handler)
   60|      0|            }
   61|      0|        }
   62|      0|        let pathSegments = ("*/" + stripQuery(path)).split("/")
   63|      0|        var pathSegmentsGenerator = pathSegments.makeIterator()
   64|      0|        var params = [String:String]()
   65|      0|        if let handler = findHandler(&rootNode, params: &params, generator: &pathSegmentsGenerator) {
   66|      0|            return (params, handler)
   67|      0|        }
   68|      0|        return nil
   69|      0|    }
   70|       |    
   71|      0|    private func inflate(_ node: inout Node, generator: inout IndexingIterator<[String]>) -> Node {
   72|      0|        if let pathSegment = generator.next() {
   73|      0|            if let _ = node.nodes[pathSegment] {
   74|      0|                return inflate(&node.nodes[pathSegment]!, generator: &generator)
   75|      0|            }
   76|      0|            var nextNode = Node()
   77|      0|            node.nodes[pathSegment] = nextNode
   78|      0|            return inflate(&nextNode, generator: &generator)
   79|      0|        }
   80|      0|        return node
   81|      0|    }
   82|       |    
   83|      0|    private func findHandler(_ node: inout Node, params: inout [String: String], generator: inout IndexingIterator<[String]>) -> ((HttpRequest) -> HttpResponse)? {
   84|      0|        guard let pathToken = generator.next()?.removingPercentEncoding else {
   85|      0|            // if it's the last element of the requested URL, check if there is a pattern with variable tail.
   86|      0|            if let variableNode = node.nodes.filter({ $0.0.first == ":" }).first {
   87|      0|                if variableNode.value.nodes.isEmpty {
   88|      0|                    params[variableNode.0] = ""
   89|      0|                    return variableNode.value.handler
   90|      0|                }
   91|      0|            }
   92|      0|            return node.handler
   93|      0|        }
   94|      0|        let variableNodes = node.nodes.filter { $0.0.first == ":" }
   95|      0|        if let variableNode = variableNodes.first {
   96|      0|            if variableNode.1.nodes.count == 0 {
   97|      0|                // if it's the last element of the pattern and it's a variable, stop the search and
   98|      0|                // append a tail as a value for the variable.
   99|      0|                let tail = generator.joined(separator: "/")
  100|      0|                if tail.count > 0 {
  101|      0|                    params[variableNode.0] = pathToken + "/" + tail
  102|      0|                } else {
  103|      0|                    params[variableNode.0] = pathToken
  104|      0|                }
  105|      0|                return variableNode.1.handler
  106|      0|            }
  107|      0|            params[variableNode.0] = pathToken
  108|      0|            return findHandler(&node.nodes[variableNode.0]!, params: &params, generator: &generator)
  109|      0|        }
  110|      0|        if var node = node.nodes[pathToken] {
  111|      0|            return findHandler(&node, params: &params, generator: &generator)
  112|      0|        }
  113|      0|        if var node = node.nodes["*"] {
  114|      0|            return findHandler(&node, params: &params, generator: &generator)
  115|      0|        }
  116|      0|        if let startStarNode = node.nodes["**"] {
  117|      0|            let startStarNodeKeys = startStarNode.nodes.keys
  118|      0|            while let pathToken = generator.next() {
  119|      0|                if startStarNodeKeys.contains(pathToken) {
  120|      0|                    return findHandler(&startStarNode.nodes[pathToken]!, params: &params, generator: &generator)
  121|      0|                }
  122|      0|            }
  123|      0|        }
  124|      0|        return nil
  125|      0|    }
  126|       |    
  127|      0|    private func stripQuery(_ path: String) -> String {
  128|      0|        if let path = path.components(separatedBy: "?").first {
  129|      0|            return path
  130|      0|        }
  131|      0|        return path
  132|      0|    }
  133|       |}
  134|       |
  135|       |extension String {
  136|       |    
  137|       |    func split(_ separator: Character) -> [String] {
  138|      0|        return self.split { $0 == separator }.map(String.init)
  139|       |    }
  140|       |    
  141|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpServer.swift:
    1|       |//
    2|       |//  HttpServer.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class HttpServer: HttpServerIO {
   11|       |    
   12|       |    public static let VERSION = "1.3.3"
   13|       |    
   14|       |    private let router = HttpRouter()
   15|       |    
   16|      0|    public override init() {
   17|      0|        self.DELETE = MethodRoute(method: "DELETE", router: router)
   18|      0|        self.PATCH  = MethodRoute(method: "PATCH", router: router)
   19|      0|        self.HEAD   = MethodRoute(method: "HEAD", router: router)
   20|      0|        self.POST   = MethodRoute(method: "POST", router: router)
   21|      0|        self.GET    = MethodRoute(method: "GET", router: router)
   22|      0|        self.PUT    = MethodRoute(method: "PUT", router: router)
   23|      0|        
   24|      0|        self.delete = MethodRoute(method: "DELETE", router: router)
   25|      0|        self.patch  = MethodRoute(method: "PATCH", router: router)
   26|      0|        self.head   = MethodRoute(method: "HEAD", router: router)
   27|      0|        self.post   = MethodRoute(method: "POST", router: router)
   28|      0|        self.get    = MethodRoute(method: "GET", router: router)
   29|      0|        self.put    = MethodRoute(method: "PUT", router: router)
   30|      0|    }
   31|       |    
   32|       |    public var DELETE, PATCH, HEAD, POST, GET, PUT : MethodRoute
   33|       |    public var delete, patch, head, post, get, put : MethodRoute
   34|       |    
   35|       |    public subscript(path: String) -> ((HttpRequest) -> HttpResponse)? {
   36|      0|        set {
   37|      0|            router.register(nil, path: path, handler: newValue)
   38|      0|        }
   39|       |        get { return nil }
   40|       |    }
   41|       |    
   42|      0|    public var routes: [String] {
   43|      0|        return router.routes();
   44|      0|    }
   45|       |    
   46|       |    public var notFoundHandler: ((HttpRequest) -> HttpResponse)?
   47|       |    
   48|       |    public var middleware = Array<(HttpRequest) -> HttpResponse?>()
   49|       |
   50|      0|    override public func dispatch(_ request: HttpRequest) -> ([String:String], (HttpRequest) -> HttpResponse) {
   51|      0|        for layer in middleware {
   52|      0|            if let response = layer(request) {
   53|      0|                return ([:], { _ in response })
   54|      0|            }
   55|      0|        }
   56|      0|        if let result = router.route(request.method, path: request.path) {
   57|      0|            return result
   58|      0|        }
   59|      0|        if let notFoundHandler = self.notFoundHandler {
   60|      0|            return ([:], notFoundHandler)
   61|      0|        }
   62|      0|        return super.dispatch(request)
   63|      0|    }
   64|       |    
   65|       |    public struct MethodRoute {
   66|       |        public let method: String
   67|       |        public let router: HttpRouter
   68|       |        public subscript(path: String) -> ((HttpRequest) -> HttpResponse)? {
   69|      0|            set {
   70|      0|                router.register(method, path: path, handler: newValue)
   71|      0|            }
   72|       |            get { return nil }
   73|       |        }
   74|       |    }
   75|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/HttpServerIO.swift:
    1|       |//
    2|       |//  HttpServer.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Dispatch
   10|       |
   11|       |public protocol HttpServerIODelegate: class {
   12|       |    func socketConnectionReceived(_ socket: Socket)
   13|       |}
   14|       |
   15|       |public class HttpServerIO {
   16|       |
   17|       |    public weak var delegate : HttpServerIODelegate?
   18|       |
   19|       |    private var socket = Socket(socketFileDescriptor: -1)
   20|       |    private var sockets = Set<Socket>()
   21|       |
   22|       |    public enum HttpServerIOState: Int32 {
   23|       |        case starting
   24|       |        case running
   25|       |        case stopping
   26|       |        case stopped
   27|       |    }
   28|       |
   29|       |    private var stateValue: Int32 = HttpServerIOState.stopped.rawValue
   30|       |
   31|       |    public private(set) var state: HttpServerIOState {
   32|      0|        get {
   33|      0|            return HttpServerIOState(rawValue: stateValue)!
   34|      0|        }
   35|      0|        set(state) {
   36|      0|            #if !os(Linux)
   37|      0|            OSAtomicCompareAndSwapInt(self.state.rawValue, state.rawValue, &stateValue)
   38|      0|            #else
   39|      0|            //TODO - hehe :)
   40|      0|            self.stateValue = state.rawValue
   41|      0|            #endif
   42|      0|        }
   43|       |    }
   44|       |
   45|      0|    public var operating: Bool { get { return self.state == .running } }
   46|       |
   47|       |    /// String representation of the IPv4 address to receive requests from.
   48|       |    /// It's only used when the server is started with `forceIPv4` option set to true.
   49|       |    /// Otherwise, `listenAddressIPv6` will be used.
   50|       |    public var listenAddressIPv4: String?
   51|       |
   52|       |    /// String representation of the IPv6 address to receive requests from.
   53|       |    /// It's only used when the server is started with `forceIPv4` option set to false.
   54|       |    /// Otherwise, `listenAddressIPv4` will be used.
   55|       |    public var listenAddressIPv6: String?
   56|       |
   57|       |    private let queue = DispatchQueue(label: "swifter.httpserverio.clientsockets")
   58|       |
   59|      0|    public func port() throws -> Int {
   60|      0|        return Int(try socket.port())
   61|      0|    }
   62|       |
   63|      0|    public func isIPv4() throws -> Bool {
   64|      0|        return try socket.isIPv4()
   65|      0|    }
   66|       |
   67|      0|    deinit {
   68|      0|        stop()
   69|      0|    }
   70|       |
   71|       |    @available(macOS 10.10, *)
   72|      0|    public func start(_ port: in_port_t = 8080, forceIPv4: Bool = false, priority: DispatchQoS.QoSClass = DispatchQoS.QoSClass.background) throws {
   73|      0|        guard !self.operating else { return }
   74|      0|        stop()
   75|      0|        self.state = .starting
   76|      0|        let address = forceIPv4 ? listenAddressIPv4 : listenAddressIPv6
   77|      0|        self.socket = try Socket.tcpSocketForListen(port, forceIPv4, SOMAXCONN, address)
   78|      0|        self.state = .running
   79|      0|        DispatchQueue.global(qos: priority).async { [weak self] in
   80|      0|            guard let strongSelf = self else { return }
   81|      0|            guard strongSelf.operating else { return }
   82|      0|            while let socket = try? strongSelf.socket.acceptClientSocket() {
   83|      0|                DispatchQueue.global(qos: priority).async { [weak self] in
   84|      0|                    guard let strongSelf = self else { return }
   85|      0|                    guard strongSelf.operating else { return }
   86|      0|                    strongSelf.queue.async {
   87|      0|                        strongSelf.sockets.insert(socket)
   88|      0|                    }
   89|      0|                    strongSelf.handleConnection(socket)
   90|      0|                    strongSelf.queue.async {
   91|      0|                        strongSelf.sockets.remove(socket)
   92|      0|                    }
   93|      0|                }
   94|      0|            }
   95|      0|            strongSelf.stop()
   96|      0|        }
   97|      0|    }
   98|       |
   99|      0|    public func stop() {
  100|      0|        guard self.operating else { return }
  101|      0|        self.state = .stopping
  102|      0|        // Shutdown connected peers because they can live in 'keep-alive' or 'websocket' loops.
  103|      0|        for socket in self.sockets {
  104|      0|            socket.close()
  105|      0|        }
  106|      0|        self.queue.sync {
  107|      0|            self.sockets.removeAll(keepingCapacity: true)
  108|      0|        }
  109|      0|        socket.close()
  110|      0|        self.state = .stopped
  111|      0|    }
  112|       |
  113|      0|    public func dispatch(_ request: HttpRequest) -> ([String: String], (HttpRequest) -> HttpResponse) {
  114|      0|        return ([:], { _ in HttpResponse.notFound })
  115|      0|    }
  116|       |
  117|      0|    private func handleConnection(_ socket: Socket) {
  118|      0|        let parser = HttpParser()
  119|      0|        while self.operating, let request = try? parser.readHttpRequest(socket) {
  120|      0|            let request = request
  121|      0|            request.address = try? socket.peername()
  122|      0|            let (params, handler) = self.dispatch(request)
  123|      0|            request.params = params
  124|      0|            let response = handler(request)
  125|      0|            var keepConnection = parser.supportsKeepAlive(request.headers)
  126|      0|            do {
  127|      0|                if self.operating {
  128|      0|                    keepConnection = try self.respond(socket, response: response, keepAlive: keepConnection)
  129|      0|                }
  130|      0|            } catch {
  131|      0|                print("Failed to send response: \(error)")
  132|      0|                break
  133|      0|            }
  134|      0|            if let session = response.socketSession() {
  135|      0|                delegate?.socketConnectionReceived(socket)
  136|      0|                session(socket)
  137|      0|                break
  138|      0|            }
  139|      0|            if !keepConnection { break }
  140|      0|        }
  141|      0|        socket.close()
  142|      0|    }
  143|       |
  144|       |    private struct InnerWriteContext: HttpResponseBodyWriter {
  145|       |
  146|       |        let socket: Socket
  147|       |
  148|      0|        func write(_ file: String.File) throws {
  149|      0|            try socket.writeFile(file)
  150|      0|        }
  151|       |
  152|      0|        func write(_ data: [UInt8]) throws {
  153|      0|            try write(ArraySlice(data))
  154|      0|        }
  155|       |
  156|       |        func write(_ data: ArraySlice<UInt8>) throws {
  157|       |            try socket.writeUInt8(data)
  158|       |        }
  159|       |
  160|      0|        func write(_ data: NSData) throws {
  161|      0|            try socket.writeData(data)
  162|      0|        }
  163|       |
  164|      0|        func write(_ data: Data) throws {
  165|      0|            try socket.writeData(data)
  166|      0|        }
  167|       |    }
  168|       |
  169|      0|    private func respond(_ socket: Socket, response: HttpResponse, keepAlive: Bool) throws -> Bool {
  170|      0|        guard self.operating else { return false }
  171|      0|
  172|      0|        // Some web-socket clients (like Jetfire) expects to have header section in a single packet.
  173|      0|        // We can't promise that but make sure we invoke "write" only once for response header section.
  174|      0|        
  175|      0|        var responseHeader = String()
  176|      0|
  177|      0|        responseHeader.append("HTTP/1.1 \(response.statusCode()) \(response.reasonPhrase())\r\n")
  178|      0|
  179|      0|        let content = response.content()
  180|      0|
  181|      0|        if content.length >= 0 {
  182|      0|            responseHeader.append("Content-Length: \(content.length)\r\n")
  183|      0|        }
  184|      0|
  185|      0|        if keepAlive && content.length != -1 {
  186|      0|            responseHeader.append("Connection: keep-alive\r\n")
  187|      0|        }
  188|      0|
  189|      0|        for (name, value) in response.headers() {
  190|      0|            responseHeader.append("\(name): \(value)\r\n")
  191|      0|        }
  192|      0|
  193|      0|        responseHeader.append("\r\n")
  194|      0|
  195|      0|        try socket.writeUTF8(responseHeader)
  196|      0|
  197|      0|        if let writeClosure = content.write {
  198|      0|            let context = InnerWriteContext(socket: socket)
  199|      0|            try writeClosure(context)
  200|      0|        }
  201|      0|
  202|      0|        return keepAlive && content.length != -1;
  203|      0|    }
  204|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/MimeTypes.swift:
    1|       |//
    2|       |//  MimeTypes.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Created by Daniel Große on 16.02.18.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |internal let DEFAULT_MIME_TYPE = "application/octet-stream"
   11|       |
   12|       |internal let mimeTypes = [
   13|       |    "html": "text/html",
   14|       |    "htm": "text/html",
   15|       |    "shtml": "text/html",
   16|       |    "css": "text/css",
   17|       |    "xml": "text/xml",
   18|       |    "gif": "image/gif",
   19|       |    "jpeg": "image/jpeg",
   20|       |    "jpg": "image/jpeg",
   21|       |    "js": "application/javascript",
   22|       |    "atom": "application/atom+xml",
   23|       |    "rss": "application/rss+xml",
   24|       |    "mml": "text/mathml",
   25|       |    "txt": "text/plain",
   26|       |    "jad": "text/vnd.sun.j2me.app-descriptor",
   27|       |    "wml": "text/vnd.wap.wml",
   28|       |    "htc": "text/x-component",
   29|       |    "png": "image/png",
   30|       |    "tif": "image/tiff",
   31|       |    "tiff": "image/tiff",
   32|       |    "wbmp": "image/vnd.wap.wbmp",
   33|       |    "ico": "image/x-icon",
   34|       |    "jng": "image/x-jng",
   35|       |    "bmp": "image/x-ms-bmp",
   36|       |    "svg": "image/svg+xml",
   37|       |    "svgz": "image/svg+xml",
   38|       |    "webp": "image/webp",
   39|       |    "woff": "application/font-woff",
   40|       |    "jar": "application/java-archive",
   41|       |    "war": "application/java-archive",
   42|       |    "ear": "application/java-archive",
   43|       |    "json": "application/json",
   44|       |    "hqx": "application/mac-binhex40",
   45|       |    "doc": "application/msword",
   46|       |    "pdf": "application/pdf",
   47|       |    "ps": "application/postscript",
   48|       |    "eps": "application/postscript",
   49|       |    "ai": "application/postscript",
   50|       |    "rtf": "application/rtf",
   51|       |    "m3u8": "application/vnd.apple.mpegurl",
   52|       |    "xls": "application/vnd.ms-excel",
   53|       |    "eot": "application/vnd.ms-fontobject",
   54|       |    "ppt": "application/vnd.ms-powerpoint",
   55|       |    "wmlc": "application/vnd.wap.wmlc",
   56|       |    "kml": "application/vnd.google-earth.kml+xml",
   57|       |    "kmz": "application/vnd.google-earth.kmz",
   58|       |    "7z": "application/x-7z-compressed",
   59|       |    "cco": "application/x-cocoa",
   60|       |    "jardiff": "application/x-java-archive-diff",
   61|       |    "jnlp": "application/x-java-jnlp-file",
   62|       |    "run": "application/x-makeself",
   63|       |    "pl": "application/x-perl",
   64|       |    "pm": "application/x-perl",
   65|       |    "prc": "application/x-pilot",
   66|       |    "pdb": "application/x-pilot",
   67|       |    "rar": "application/x-rar-compressed",
   68|       |    "rpm": "application/x-redhat-package-manager",
   69|       |    "sea": "application/x-sea",
   70|       |    "swf": "application/x-shockwave-flash",
   71|       |    "sit": "application/x-stuffit",
   72|       |    "tcl": "application/x-tcl",
   73|       |    "tk": "application/x-tcl",
   74|       |    "der": "application/x-x509-ca-cert",
   75|       |    "pem": "application/x-x509-ca-cert",
   76|       |    "crt": "application/x-x509-ca-cert",
   77|       |    "xpi": "application/x-xpinstall",
   78|       |    "xhtml": "application/xhtml+xml",
   79|       |    "xspf": "application/xspf+xml",
   80|       |    "zip": "application/zip",
   81|       |    "bin": "application/octet-stream",
   82|       |    "exe": "application/octet-stream",
   83|       |    "dll": "application/octet-stream",
   84|       |    "deb": "application/octet-stream",
   85|       |    "dmg": "application/octet-stream",
   86|       |    "iso": "application/octet-stream",
   87|       |    "img": "application/octet-stream",
   88|       |    "msi": "application/octet-stream",
   89|       |    "msp": "application/octet-stream",
   90|       |    "msm": "application/octet-stream",
   91|       |    "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
   92|       |    "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
   93|       |    "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
   94|       |    "mid": "audio/midi",
   95|       |    "midi": "audio/midi",
   96|       |    "kar": "audio/midi",
   97|       |    "mp3": "audio/mpeg",
   98|       |    "ogg": "audio/ogg",
   99|       |    "m4a": "audio/x-m4a",
  100|       |    "ra": "audio/x-realaudio",
  101|       |    "3gpp": "video/3gpp",
  102|       |    "3gp": "video/3gpp",
  103|       |    "ts": "video/mp2t",
  104|       |    "mp4": "video/mp4",
  105|       |    "mpeg": "video/mpeg",
  106|       |    "mpg": "video/mpeg",
  107|       |    "mov": "video/quicktime",
  108|       |    "webm": "video/webm",
  109|       |    "flv": "video/x-flv",
  110|       |    "m4v": "video/x-m4v",
  111|       |    "mng": "video/x-mng",
  112|       |    "asx": "video/x-ms-asf",
  113|       |    "asf": "video/x-ms-asf",
  114|       |    "wmv": "video/x-ms-wmv",
  115|       |    "avi": "video/x-msvideo"
  116|       |]
  117|       |
  118|      0|internal func MimeType(ext: String?) -> String {
  119|      0|    if ext != nil && mimeTypes.contains(where: { $0.0 == ext!.lowercased() }) {
  120|      0|        return mimeTypes[ext!.lowercased()]!
  121|      0|    }
  122|      0|    return DEFAULT_MIME_TYPE
  123|      0|}
  124|       |
  125|       |extension NSURL {
  126|      0|    public func mimeType() -> String {
  127|      0|        return MimeType(ext: self.pathExtension)
  128|      0|    }
  129|       |}
  130|       |
  131|       |extension NSString {
  132|      0|    public func mimeType() -> String {
  133|      0|        return MimeType(ext: self.pathExtension)
  134|      0|    }
  135|       |}
  136|       |
  137|       |extension String {
  138|      0|    public func mimeType() -> String {
  139|      0|        return (NSString(string: self)).mimeType()
  140|      0|    }
  141|       |}
  142|       |
  143|       |

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Process.swift:
    1|       |//
    2|       |//  Process
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class Process {
   11|       |    
   12|      0|    public static var pid: Int {
   13|      0|        return Int(getpid())
   14|      0|    }
   15|       |    
   16|      0|    public static var tid: UInt64 {
   17|      0|        #if os(Linux)
   18|      0|            return UInt64(pthread_self())
   19|      0|        #else
   20|      0|            var tid: __uint64_t = 0
   21|      0|            pthread_threadid_np(nil, &tid);
   22|      0|            return UInt64(tid)
   23|      0|        #endif
   24|      0|    }
   25|       |    
   26|       |    private static var signalsWatchers = Array<(Int32) -> Void>()
   27|       |    private static var signalsObserved = false
   28|       |    
   29|      0|    public static func watchSignals(_ callback: @escaping (Int32) -> Void) {
   30|      0|        if !signalsObserved {
   31|      0|            [SIGTERM, SIGHUP, SIGSTOP, SIGINT].forEach { item in
   32|      0|                signal(item) {
   33|      0|                    signum in Process.signalsWatchers.forEach { $0(signum) }
   34|      0|                }
   35|      0|            }
   36|      0|            signalsObserved = true
   37|      0|        }
   38|      0|        signalsWatchers.append(callback)
   39|      0|    }
   40|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Scopes.swift:
    1|       |//
    2|       |//  HttpHandlers+Scopes.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright © 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|      0|public func scopes(_ scope: @escaping Closure) -> ((HttpRequest) -> HttpResponse) {
   11|      0|    return { r in
   12|      0|        ScopesBuffer[Process.tid] = ""
   13|      0|        scope()
   14|      0|        return .raw(200, "OK", ["Content-Type": "text/html"], {
   15|      0|            try? $0.write([UInt8](("<!DOCTYPE html>"  + (ScopesBuffer[Process.tid] ?? "")).utf8))
   16|      0|        })
   17|      0|    }
   18|      0|}
   19|       |
   20|       |public typealias Closure = () -> Void
   21|       |
   22|       |public var idd: String? = nil
   23|       |public var dir: String? = nil
   24|       |public var rel: String? = nil
   25|       |public var rev: String? = nil
   26|       |public var alt: String? = nil
   27|       |public var forr: String? = nil
   28|       |public var src: String? = nil
   29|       |public var type: String? = nil
   30|       |public var href: String? = nil
   31|       |public var text: String? = nil
   32|       |public var abbr: String? = nil
   33|       |public var size: String? = nil
   34|       |public var face: String? = nil
   35|       |public var char: String? = nil
   36|       |public var cite: String? = nil
   37|       |public var span: String? = nil
   38|       |public var data: String? = nil
   39|       |public var axis: String? = nil
   40|       |public var Name: String? = nil
   41|       |public var name: String? = nil
   42|       |public var code: String? = nil
   43|       |public var link: String? = nil
   44|       |public var lang: String? = nil
   45|       |public var cols: String? = nil
   46|       |public var rows: String? = nil
   47|       |public var ismap: String? = nil
   48|       |public var shape: String? = nil
   49|       |public var style: String? = nil
   50|       |public var alink: String? = nil
   51|       |public var width: String? = nil
   52|       |public var rules: String? = nil
   53|       |public var align: String? = nil
   54|       |public var frame: String? = nil
   55|       |public var vlink: String? = nil
   56|       |public var deferr: String? = nil
   57|       |public var color: String? = nil
   58|       |public var media: String? = nil
   59|       |public var title: String? = nil
   60|       |public var scope: String? = nil
   61|       |public var classs: String? = nil
   62|       |public var value: String? = nil
   63|       |public var clear: String? = nil
   64|       |public var start: String? = nil
   65|       |public var label: String? = nil
   66|       |public var action: String? = nil
   67|       |public var height: String? = nil
   68|       |public var method: String? = nil
   69|       |public var acceptt: String? = nil
   70|       |public var object: String? = nil
   71|       |public var scheme: String? = nil
   72|       |public var coords: String? = nil
   73|       |public var usemap: String? = nil
   74|       |public var onblur: String? = nil
   75|       |public var nohref: String? = nil
   76|       |public var nowrap: String? = nil
   77|       |public var hspace: String? = nil
   78|       |public var border: String? = nil
   79|       |public var valign: String? = nil
   80|       |public var vspace: String? = nil
   81|       |public var onload: String? = nil
   82|       |public var target: String? = nil
   83|       |public var prompt: String? = nil
   84|       |public var onfocus: String? = nil
   85|       |public var enctype: String? = nil
   86|       |public var onclick: String? = nil
   87|       |public var onkeyup: String? = nil
   88|       |public var profile: String? = nil
   89|       |public var version: String? = nil
   90|       |public var onreset: String? = nil
   91|       |public var charset: String? = nil
   92|       |public var standby: String? = nil
   93|       |public var colspan: String? = nil
   94|       |public var charoff: String? = nil
   95|       |public var classid: String? = nil
   96|       |public var compact: String? = nil
   97|       |public var declare: String? = nil
   98|       |public var rowspan: String? = nil
   99|       |public var checked: String? = nil
  100|       |public var archive: String? = nil
  101|       |public var bgcolor: String? = nil
  102|       |public var content: String? = nil
  103|       |public var noshade: String? = nil
  104|       |public var summary: String? = nil
  105|       |public var headers: String? = nil
  106|       |public var onselect: String? = nil
  107|       |public var readonly: String? = nil
  108|       |public var tabindex: String? = nil
  109|       |public var onchange: String? = nil
  110|       |public var noresize: String? = nil
  111|       |public var disabled: String? = nil
  112|       |public var longdesc: String? = nil
  113|       |public var codebase: String? = nil
  114|       |public var language: String? = nil
  115|       |public var datetime: String? = nil
  116|       |public var selected: String? = nil
  117|       |public var hreflang: String? = nil
  118|       |public var onsubmit: String? = nil
  119|       |public var multiple: String? = nil
  120|       |public var onunload: String? = nil
  121|       |public var codetype: String? = nil
  122|       |public var scrolling: String? = nil
  123|       |public var onkeydown: String? = nil
  124|       |public var maxlength: String? = nil
  125|       |public var valuetype: String? = nil
  126|       |public var accesskey: String? = nil
  127|       |public var onmouseup: String? = nil
  128|       |public var autofocus: String? = nil
  129|       |public var onkeypress: String? = nil
  130|       |public var ondblclick: String? = nil
  131|       |public var onmouseout: String? = nil
  132|       |public var httpEquiv: String? = nil
  133|       |public var background: String? = nil
  134|       |public var onmousemove: String? = nil
  135|       |public var onmouseover: String? = nil
  136|       |public var cellpadding: String? = nil
  137|       |public var onmousedown: String? = nil
  138|       |public var frameborder: String? = nil
  139|       |public var marginwidth: String? = nil
  140|       |public var cellspacing: String? = nil
  141|       |public var placeholder: String? = nil
  142|       |public var marginheight: String? = nil
  143|       |public var acceptCharset: String? = nil
  144|       |
  145|       |public var inner: String? = nil
  146|       |
  147|      0|public func a(_ c: Closure) { element("a", c) }
  148|      0|public func b(_ c: Closure) { element("b", c) }
  149|      0|public func i(_ c: Closure) { element("i", c) }
  150|      0|public func p(_ c: Closure) { element("p", c) }
  151|      0|public func q(_ c: Closure) { element("q", c) }
  152|      0|public func s(_ c: Closure) { element("s", c) }
  153|      0|public func u(_ c: Closure) { element("u", c) }
  154|       |
  155|      0|public func br(_ c: Closure) { element("br", c) }
  156|      0|public func dd(_ c: Closure) { element("dd", c) }
  157|      0|public func dl(_ c: Closure) { element("dl", c) }
  158|      0|public func dt(_ c: Closure) { element("dt", c) }
  159|      0|public func em(_ c: Closure) { element("em", c) }
  160|      0|public func hr(_ c: Closure) { element("hr", c) }
  161|      0|public func li(_ c: Closure) { element("li", c) }
  162|      0|public func ol(_ c: Closure) { element("ol", c) }
  163|      0|public func rp(_ c: Closure) { element("rp", c) }
  164|      0|public func rt(_ c: Closure) { element("rt", c) }
  165|      0|public func td(_ c: Closure) { element("td", c) }
  166|      0|public func th(_ c: Closure) { element("th", c) }
  167|      0|public func tr(_ c: Closure) { element("tr", c) }
  168|      0|public func tt(_ c: Closure) { element("tt", c) }
  169|      0|public func ul(_ c: Closure) { element("ul", c) }
  170|       |
  171|      0|public func ul<T: Sequence>(_ collection: T, _ c: @escaping (T.Iterator.Element) -> Void) {
  172|      0|    element("ul", {
  173|      0|        for item in collection {
  174|      0|            c(item)
  175|      0|        }
  176|      0|    })
  177|      0|}
  178|       |
  179|      0|public func h1(_ c: Closure) { element("h1", c) }
  180|      0|public func h2(_ c: Closure) { element("h2", c) }
  181|      0|public func h3(_ c: Closure) { element("h3", c) }
  182|      0|public func h4(_ c: Closure) { element("h4", c) }
  183|      0|public func h5(_ c: Closure) { element("h5", c) }
  184|      0|public func h6(_ c: Closure) { element("h6", c) }
  185|       |
  186|      0|public func bdi(_ c: Closure) { element("bdi", c) }
  187|      0|public func bdo(_ c: Closure) { element("bdo", c) }
  188|      0|public func big(_ c: Closure) { element("big", c) }
  189|      0|public func col(_ c: Closure) { element("col", c) }
  190|      0|public func del(_ c: Closure) { element("del", c) }
  191|      0|public func dfn(_ c: Closure) { element("dfn", c) }
  192|      0|public func dir(_ c: Closure) { element("dir", c) }
  193|      0|public func div(_ c: Closure) { element("div", c) }
  194|      0|public func img(_ c: Closure) { element("img", c) }
  195|      0|public func ins(_ c: Closure) { element("ins", c) }
  196|      0|public func kbd(_ c: Closure) { element("kbd", c) }
  197|      0|public func map(_ c: Closure) { element("map", c) }
  198|      0|public func nav(_ c: Closure) { element("nav", c) }
  199|      0|public func pre(_ c: Closure) { element("pre", c) }
  200|      0|public func rtc(_ c: Closure) { element("rtc", c) }
  201|      0|public func sub(_ c: Closure) { element("sub", c) }
  202|      0|public func sup(_ c: Closure) { element("sup", c) }
  203|       |
  204|      0|public func varr(_ c: Closure) { element("var", c) }
  205|      0|public func wbr(_ c: Closure) { element("wbr", c) }
  206|      0|public func xmp(_ c: Closure) { element("xmp", c) }
  207|       |
  208|      0|public func abbr(_ c: Closure) { element("abbr", c) }
  209|      0|public func area(_ c: Closure) { element("area", c) }
  210|      0|public func base(_ c: Closure) { element("base", c) }
  211|      0|public func body(_ c: Closure) { element("body", c) }
  212|      0|public func cite(_ c: Closure) { element("cite", c) }
  213|      0|public func code(_ c: Closure) { element("code", c) }
  214|      0|public func data(_ c: Closure) { element("data", c) }
  215|      0|public func font(_ c: Closure) { element("font", c) }
  216|      0|public func form(_ c: Closure) { element("form", c) }
  217|      0|public func head(_ c: Closure) { element("head", c) }
  218|      0|public func html(_ c: Closure) { element("html", c) }
  219|      0|public func link(_ c: Closure) { element("link", c) }
  220|      0|public func main(_ c: Closure) { element("main", c) }
  221|      0|public func mark(_ c: Closure) { element("mark", c) }
  222|      0|public func menu(_ c: Closure) { element("menu", c) }
  223|      0|public func meta(_ c: Closure) { element("meta", c) }
  224|      0|public func nobr(_ c: Closure) { element("nobr", c) }
  225|      0|public func ruby(_ c: Closure) { element("ruby", c) }
  226|      0|public func samp(_ c: Closure) { element("samp", c) }
  227|      0|public func span(_ c: Closure) { element("span", c) }
  228|      0|public func time(_ c: Closure) { element("time", c) }
  229|       |
  230|      0|public func aside(_ c: Closure) { element("aside", c) }
  231|      0|public func audio(_ c: Closure) { element("audio", c) }
  232|      0|public func blink(_ c: Closure) { element("blink", c) }
  233|      0|public func embed(_ c: Closure) { element("embed", c) }
  234|      0|public func frame(_ c: Closure) { element("frame", c) }
  235|      0|public func image(_ c: Closure) { element("image", c) }
  236|      0|public func input(_ c: Closure) { element("input", c) }
  237|      0|public func label(_ c: Closure) { element("label", c) }
  238|      0|public func meter(_ c: Closure) { element("meter", c) }
  239|      0|public func param(_ c: Closure) { element("param", c) }
  240|      0|public func small(_ c: Closure) { element("small", c) }
  241|      0|public func style(_ c: Closure) { element("style", c) }
  242|      0|public func table(_ c: Closure) { element("table", c) }
  243|       |
  244|      0|public func table<T: Sequence>(_ collection: T, c: @escaping (T.Iterator.Element) -> Void) {
  245|      0|    element("table", {
  246|      0|        for item in collection {
  247|      0|            c(item)
  248|      0|        }
  249|      0|    })
  250|      0|}
  251|       |
  252|      0|public func tbody(_ c: Closure) { element("tbody", c) }
  253|       |
  254|      0|public func tbody<T: Sequence>(_ collection: T, c: @escaping (T.Iterator.Element) -> Void) {
  255|      0|    element("tbody", {
  256|      0|        for item in collection {
  257|      0|            c(item)
  258|      0|        }
  259|      0|    })
  260|      0|}
  261|       |
  262|      0|public func tfoot(_ c: Closure) { element("tfoot", c) }
  263|      0|public func thead(_ c: Closure) { element("thead", c) }
  264|      0|public func title(_ c: Closure) { element("title", c) }
  265|      0|public func track(_ c: Closure) { element("track", c) }
  266|      0|public func video(_ c: Closure) { element("video", c) }
  267|       |
  268|      0|public func applet(_ c: Closure) { element("applet", c) }
  269|      0|public func button(_ c: Closure) { element("button", c) }
  270|      0|public func canvas(_ c: Closure) { element("canvas", c) }
  271|      0|public func center(_ c: Closure) { element("center", c) }
  272|      0|public func dialog(_ c: Closure) { element("dialog", c) }
  273|      0|public func figure(_ c: Closure) { element("figure", c) }
  274|      0|public func footer(_ c: Closure) { element("footer", c) }
  275|      0|public func header(_ c: Closure) { element("header", c) }
  276|      0|public func hgroup(_ c: Closure) { element("hgroup", c) }
  277|      0|public func iframe(_ c: Closure) { element("iframe", c) }
  278|      0|public func keygen(_ c: Closure) { element("keygen", c) }
  279|      0|public func legend(_ c: Closure) { element("legend", c) }
  280|      0|public func object(_ c: Closure) { element("object", c) }
  281|      0|public func option(_ c: Closure) { element("option", c) }
  282|      0|public func output(_ c: Closure) { element("output", c) }
  283|      0|public func script(_ c: Closure) { element("script", c) }
  284|      0|public func select(_ c: Closure) { element("select", c) }
  285|      0|public func shadow(_ c: Closure) { element("shadow", c) }
  286|      0|public func source(_ c: Closure) { element("source", c) }
  287|      0|public func spacer(_ c: Closure) { element("spacer", c) }
  288|      0|public func strike(_ c: Closure) { element("strike", c) }
  289|      0|public func strong(_ c: Closure) { element("strong", c) }
  290|       |
  291|      0|public func acronym(_ c: Closure) { element("acronym", c) }
  292|      0|public func address(_ c: Closure) { element("address", c) }
  293|      0|public func article(_ c: Closure) { element("article", c) }
  294|      0|public func bgsound(_ c: Closure) { element("bgsound", c) }
  295|      0|public func caption(_ c: Closure) { element("caption", c) }
  296|      0|public func command(_ c: Closure) { element("command", c) }
  297|      0|public func content(_ c: Closure) { element("content", c) }
  298|      0|public func details(_ c: Closure) { element("details", c) }
  299|      0|public func elementt(_ c: Closure) { element("element", c) }
  300|      0|public func isindex(_ c: Closure) { element("isindex", c) }
  301|      0|public func listing(_ c: Closure) { element("listing", c) }
  302|      0|public func marquee(_ c: Closure) { element("marquee", c) }
  303|      0|public func noembed(_ c: Closure) { element("noembed", c) }
  304|      0|public func picture(_ c: Closure) { element("picture", c) }
  305|      0|public func section(_ c: Closure) { element("section", c) }
  306|      0|public func summary(_ c: Closure) { element("summary", c) }
  307|       |
  308|      0|public func basefont(_ c: Closure) { element("basefont", c) }
  309|      0|public func colgroup(_ c: Closure) { element("colgroup", c) }
  310|      0|public func datalist(_ c: Closure) { element("datalist", c) }
  311|      0|public func fieldset(_ c: Closure) { element("fieldset", c) }
  312|      0|public func frameset(_ c: Closure) { element("frameset", c) }
  313|      0|public func menuitem(_ c: Closure) { element("menuitem", c) }
  314|      0|public func multicol(_ c: Closure) { element("multicol", c) }
  315|      0|public func noframes(_ c: Closure) { element("noframes", c) }
  316|      0|public func noscript(_ c: Closure) { element("noscript", c) }
  317|      0|public func optgroup(_ c: Closure) { element("optgroup", c) }
  318|      0|public func progress(_ c: Closure) { element("progress", c) }
  319|      0|public func template(_ c: Closure) { element("template", c) }
  320|      0|public func textarea(_ c: Closure) { element("textarea", c) }
  321|       |
  322|      0|public func plaintext(_ c: Closure) { element("plaintext", c) }
  323|      0|public func javascript(_ c: Closure) { element("script", ["type": "text/javascript"], c) }
  324|      0|public func blockquote(_ c: Closure) { element("blockquote", c) }
  325|      0|public func figcaption(_ c: Closure) { element("figcaption", c) }
  326|       |
  327|      0|public func stylesheet(_ c: Closure) { element("link", ["rel": "stylesheet", "type": "text/css"], c) }
  328|       |
  329|       |public func element(_ node: String, _ c: Closure) { evaluate(node, [:], c) }
  330|       |public func element(_ node: String, _ attrs: [String: String?] = [:], _ c: Closure) { evaluate(node, attrs, c) }
  331|       |
  332|       |var ScopesBuffer = [UInt64: String]()
  333|       |
  334|       |private func evaluate(_ node: String, _ attrs: [String: String?] = [:], _ c: Closure) {
  335|       |    
  336|       |    // Push the attributes.
  337|       |    
  338|       |    let stackid = idd
  339|       |    let stackdir = dir
  340|       |    let stackrel = rel
  341|       |    let stackrev = rev
  342|       |    let stackalt = alt
  343|       |    let stackfor = forr
  344|       |    let stacksrc = src
  345|       |    let stacktype = type
  346|       |    let stackhref = href
  347|       |    let stacktext = text
  348|       |    let stackabbr = abbr
  349|       |    let stacksize = size
  350|       |    let stackface = face
  351|       |    let stackchar = char
  352|       |    let stackcite = cite
  353|       |    let stackspan = span
  354|       |    let stackdata = data
  355|       |    let stackaxis = axis
  356|       |    let stackName = Name
  357|       |    let stackname = name
  358|       |    let stackcode = code
  359|       |    let stacklink = link
  360|       |    let stacklang = lang
  361|       |    let stackcols = cols
  362|       |    let stackrows = rows
  363|       |    let stackismap = ismap
  364|       |    let stackshape = shape
  365|       |    let stackstyle = style
  366|       |    let stackalink = alink
  367|       |    let stackwidth = width
  368|       |    let stackrules = rules
  369|       |    let stackalign = align
  370|       |    let stackframe = frame
  371|       |    let stackvlink = vlink
  372|       |    let stackdefer = deferr
  373|       |    let stackcolor = color
  374|       |    let stackmedia = media
  375|       |    let stacktitle = title
  376|       |    let stackscope = scope
  377|       |    let stackclass = classs
  378|       |    let stackvalue = value
  379|       |    let stackclear = clear
  380|       |    let stackstart = start
  381|       |    let stacklabel = label
  382|       |    let stackaction = action
  383|       |    let stackheight = height
  384|       |    let stackmethod = method
  385|       |    let stackaccept = acceptt
  386|       |    let stackobject = object
  387|       |    let stackscheme = scheme
  388|       |    let stackcoords = coords
  389|       |    let stackusemap = usemap
  390|       |    let stackonblur = onblur
  391|       |    let stacknohref = nohref
  392|       |    let stacknowrap = nowrap
  393|       |    let stackhspace = hspace
  394|       |    let stackborder = border
  395|       |    let stackvalign = valign
  396|       |    let stackvspace = vspace
  397|       |    let stackonload = onload
  398|       |    let stacktarget = target
  399|       |    let stackprompt = prompt
  400|       |    let stackonfocus = onfocus
  401|       |    let stackenctype = enctype
  402|       |    let stackonclick = onclick
  403|       |    let stackonkeyup = onkeyup
  404|       |    let stackprofile = profile
  405|       |    let stackversion = version
  406|       |    let stackonreset = onreset
  407|       |    let stackcharset = charset
  408|       |    let stackstandby = standby
  409|       |    let stackcolspan = colspan
  410|       |    let stackcharoff = charoff
  411|       |    let stackclassid = classid
  412|       |    let stackcompact = compact
  413|       |    let stackdeclare = declare
  414|       |    let stackrowspan = rowspan
  415|       |    let stackchecked = checked
  416|       |    let stackarchive = archive
  417|       |    let stackbgcolor = bgcolor
  418|       |    let stackcontent = content
  419|       |    let stacknoshade = noshade
  420|       |    let stacksummary = summary
  421|       |    let stackheaders = headers
  422|       |    let stackonselect = onselect
  423|       |    let stackreadonly = readonly
  424|       |    let stacktabindex = tabindex
  425|       |    let stackonchange = onchange
  426|       |    let stacknoresize = noresize
  427|       |    let stackdisabled = disabled
  428|       |    let stacklongdesc = longdesc
  429|       |    let stackcodebase = codebase
  430|       |    let stacklanguage = language
  431|       |    let stackdatetime = datetime
  432|       |    let stackselected = selected
  433|       |    let stackhreflang = hreflang
  434|       |    let stackonsubmit = onsubmit
  435|       |    let stackmultiple = multiple
  436|       |    let stackonunload = onunload
  437|       |    let stackcodetype = codetype
  438|       |    let stackscrolling = scrolling
  439|       |    let stackonkeydown = onkeydown
  440|       |    let stackmaxlength = maxlength
  441|       |    let stackvaluetype = valuetype
  442|       |    let stackaccesskey = accesskey
  443|       |    let stackonmouseup = onmouseup
  444|       |    let stackonkeypress = onkeypress
  445|       |    let stackondblclick = ondblclick
  446|       |    let stackonmouseout = onmouseout
  447|       |    let stackhttpEquiv = httpEquiv
  448|       |    let stackbackground = background
  449|       |    let stackonmousemove = onmousemove
  450|       |    let stackonmouseover = onmouseover
  451|       |    let stackcellpadding = cellpadding
  452|       |    let stackonmousedown = onmousedown
  453|       |    let stackframeborder = frameborder
  454|       |    let stackmarginwidth = marginwidth
  455|       |    let stackcellspacing = cellspacing
  456|       |    let stackplaceholder = placeholder
  457|       |    let stackmarginheight = marginheight
  458|       |    let stackacceptCharset = acceptCharset
  459|       |    let stackinner = inner
  460|       |    
  461|       |    // Reset the values before a nested scope evalutation.
  462|       |    
  463|       |    idd = nil
  464|       |    dir = nil
  465|       |    rel = nil
  466|       |    rev = nil
  467|       |    alt = nil
  468|       |    forr = nil
  469|       |    src = nil
  470|       |    type = nil
  471|       |    href = nil
  472|       |    text = nil
  473|       |    abbr = nil
  474|       |    size = nil
  475|       |    face = nil
  476|       |    char = nil
  477|       |    cite = nil
  478|       |    span = nil
  479|       |    data = nil
  480|       |    axis = nil
  481|       |    Name = nil
  482|       |    name = nil
  483|       |    code = nil
  484|       |    link = nil
  485|       |    lang = nil
  486|       |    cols = nil
  487|       |    rows = nil
  488|       |    ismap = nil
  489|       |    shape = nil
  490|       |    style = nil
  491|       |    alink = nil
  492|       |    width = nil
  493|       |    rules = nil
  494|       |    align = nil
  495|       |    frame = nil
  496|       |    vlink = nil
  497|       |    deferr = nil
  498|       |    color = nil
  499|       |    media = nil
  500|       |    title = nil
  501|       |    scope = nil
  502|       |    classs = nil
  503|       |    value = nil
  504|       |    clear = nil
  505|       |    start = nil
  506|       |    label = nil
  507|       |    action = nil
  508|       |    height = nil
  509|       |    method = nil
  510|       |    acceptt = nil
  511|       |    object = nil
  512|       |    scheme = nil
  513|       |    coords = nil
  514|       |    usemap = nil
  515|       |    onblur = nil
  516|       |    nohref = nil
  517|       |    nowrap = nil
  518|       |    hspace = nil
  519|       |    border = nil
  520|       |    valign = nil
  521|       |    vspace = nil
  522|       |    onload = nil
  523|       |    target = nil
  524|       |    prompt = nil
  525|       |    onfocus = nil
  526|       |    enctype = nil
  527|       |    onclick = nil
  528|       |    onkeyup = nil
  529|       |    profile = nil
  530|       |    version = nil
  531|       |    onreset = nil
  532|       |    charset = nil
  533|       |    standby = nil
  534|       |    colspan = nil
  535|       |    charoff = nil
  536|       |    classid = nil
  537|       |    compact = nil
  538|       |    declare = nil
  539|       |    rowspan = nil
  540|       |    checked = nil
  541|       |    archive = nil
  542|       |    bgcolor = nil
  543|       |    content = nil
  544|       |    noshade = nil
  545|       |    summary = nil
  546|       |    headers = nil
  547|       |    onselect = nil
  548|       |    readonly = nil
  549|       |    tabindex = nil
  550|       |    onchange = nil
  551|       |    noresize = nil
  552|       |    disabled = nil
  553|       |    longdesc = nil
  554|       |    codebase = nil
  555|       |    language = nil
  556|       |    datetime = nil
  557|       |    selected = nil
  558|       |    hreflang = nil
  559|       |    onsubmit = nil
  560|       |    multiple = nil
  561|       |    onunload = nil
  562|       |    codetype = nil
  563|       |    scrolling = nil
  564|       |    onkeydown = nil
  565|       |    maxlength = nil
  566|       |    valuetype = nil
  567|       |    accesskey = nil
  568|       |    onmouseup = nil
  569|       |    onkeypress = nil
  570|       |    ondblclick = nil
  571|       |    onmouseout = nil
  572|       |    httpEquiv = nil
  573|       |    background = nil
  574|       |    onmousemove = nil
  575|       |    onmouseover = nil
  576|       |    cellpadding = nil
  577|       |    onmousedown = nil
  578|       |    frameborder = nil
  579|       |    placeholder = nil
  580|       |    marginwidth = nil
  581|       |    cellspacing = nil
  582|       |    marginheight = nil
  583|       |    acceptCharset = nil
  584|       |    inner = nil
  585|       |    
  586|       |    ScopesBuffer[Process.tid] = (ScopesBuffer[Process.tid] ?? "") + "<" + node
  587|       |    
  588|       |    // Save the current output before the nested scope evalutation.
  589|       |    
  590|       |    var output = ScopesBuffer[Process.tid] ?? ""
  591|       |    
  592|       |    // Clear the output buffer for the evalutation.
  593|       |    
  594|       |    ScopesBuffer[Process.tid] = ""
  595|       |    
  596|       |    // Evaluate the nested scope.
  597|       |    
  598|       |    c()
  599|       |    
  600|       |    // Render attributes set by the evalutation.
  601|       |    
  602|       |    var mergedAttributes = [String: String?]()
  603|       |    
  604|       |    if let idd = idd { mergedAttributes["id"] = idd }
  605|       |    if let dir = dir { mergedAttributes["dir"] = dir }
  606|       |    if let rel = rel { mergedAttributes["rel"] = rel }
  607|       |    if let rev = rev { mergedAttributes["rev"] = rev }
  608|       |    if let alt = alt { mergedAttributes["alt"] = alt }
  609|       |    if let forr = forr { mergedAttributes["for"] = forr }
  610|       |    if let src = src { mergedAttributes["src"] = src }
  611|       |    if let type = type { mergedAttributes["type"] = type }
  612|       |    if let href = href { mergedAttributes["href"] = href }
  613|       |    if let text = text { mergedAttributes["text"] = text }
  614|       |    if let abbr = abbr { mergedAttributes["abbr"] = abbr }
  615|       |    if let size = size { mergedAttributes["size"] = size }
  616|       |    if let face = face { mergedAttributes["face"] = face }
  617|       |    if let char = char { mergedAttributes["char"] = char }
  618|       |    if let cite = cite { mergedAttributes["cite"] = cite }
  619|       |    if let span = span { mergedAttributes["span"] = span }
  620|       |    if let data = data { mergedAttributes["data"] = data }
  621|       |    if let axis = axis { mergedAttributes["axis"] = axis }
  622|       |    if let Name = Name { mergedAttributes["Name"] = Name }
  623|       |    if let name = name { mergedAttributes["name"] = name }
  624|       |    if let code = code { mergedAttributes["code"] = code }
  625|       |    if let link = link { mergedAttributes["link"] = link }
  626|       |    if let lang = lang { mergedAttributes["lang"] = lang }
  627|       |    if let cols = cols { mergedAttributes["cols"] = cols }
  628|       |    if let rows = rows { mergedAttributes["rows"] = rows }
  629|       |    if let ismap = ismap { mergedAttributes["ismap"] = ismap }
  630|       |    if let shape = shape { mergedAttributes["shape"] = shape }
  631|       |    if let style = style { mergedAttributes["style"] = style }
  632|       |    if let alink = alink { mergedAttributes["alink"] = alink }
  633|       |    if let width = width { mergedAttributes["width"] = width }
  634|       |    if let rules = rules { mergedAttributes["rules"] = rules }
  635|       |    if let align = align { mergedAttributes["align"] = align }
  636|       |    if let frame = frame { mergedAttributes["frame"] = frame }
  637|       |    if let vlink = vlink { mergedAttributes["vlink"] = vlink }
  638|       |    if let deferr = deferr { mergedAttributes["defer"] = deferr }
  639|       |    if let color = color { mergedAttributes["color"] = color }
  640|       |    if let media = media { mergedAttributes["media"] = media }
  641|       |    if let title = title { mergedAttributes["title"] = title }
  642|       |    if let scope = scope { mergedAttributes["scope"] = scope }
  643|       |    if let classs = classs { mergedAttributes["class"] = classs }
  644|       |    if let value = value { mergedAttributes["value"] = value }
  645|       |    if let clear = clear { mergedAttributes["clear"] = clear }
  646|       |    if let start = start { mergedAttributes["start"] = start }
  647|       |    if let label = label { mergedAttributes["label"] = label }
  648|       |    if let action = action { mergedAttributes["action"] = action }
  649|       |    if let height = height { mergedAttributes["height"] = height }
  650|       |    if let method = method { mergedAttributes["method"] = method }
  651|       |    if let acceptt = acceptt { mergedAttributes["accept"] = acceptt }
  652|       |    if let object = object { mergedAttributes["object"] = object }
  653|       |    if let scheme = scheme { mergedAttributes["scheme"] = scheme }
  654|       |    if let coords = coords { mergedAttributes["coords"] = coords }
  655|       |    if let usemap = usemap { mergedAttributes["usemap"] = usemap }
  656|       |    if let onblur = onblur { mergedAttributes["onblur"] = onblur }
  657|       |    if let nohref = nohref { mergedAttributes["nohref"] = nohref }
  658|       |    if let nowrap = nowrap { mergedAttributes["nowrap"] = nowrap }
  659|       |    if let hspace = hspace { mergedAttributes["hspace"] = hspace }
  660|       |    if let border = border { mergedAttributes["border"] = border }
  661|       |    if let valign = valign { mergedAttributes["valign"] = valign }
  662|       |    if let vspace = vspace { mergedAttributes["vspace"] = vspace }
  663|       |    if let onload = onload { mergedAttributes["onload"] = onload }
  664|       |    if let target = target { mergedAttributes["target"] = target }
  665|       |    if let prompt = prompt { mergedAttributes["prompt"] = prompt }
  666|       |    if let onfocus = onfocus { mergedAttributes["onfocus"] = onfocus }
  667|       |    if let enctype = enctype { mergedAttributes["enctype"] = enctype }
  668|       |    if let onclick = onclick { mergedAttributes["onclick"] = onclick }
  669|       |    if let onkeyup = onkeyup { mergedAttributes["onkeyup"] = onkeyup }
  670|       |    if let profile = profile { mergedAttributes["profile"] = profile }
  671|       |    if let version = version { mergedAttributes["version"] = version }
  672|       |    if let onreset = onreset { mergedAttributes["onreset"] = onreset }
  673|       |    if let charset = charset { mergedAttributes["charset"] = charset }
  674|       |    if let standby = standby { mergedAttributes["standby"] = standby }
  675|       |    if let colspan = colspan { mergedAttributes["colspan"] = colspan }
  676|       |    if let charoff = charoff { mergedAttributes["charoff"] = charoff }
  677|       |    if let classid = classid { mergedAttributes["classid"] = classid }
  678|       |    if let compact = compact { mergedAttributes["compact"] = compact }
  679|       |    if let declare = declare { mergedAttributes["declare"] = declare }
  680|       |    if let rowspan = rowspan { mergedAttributes["rowspan"] = rowspan }
  681|       |    if let checked = checked { mergedAttributes["checked"] = checked }
  682|       |    if let archive = archive { mergedAttributes["archive"] = archive }
  683|       |    if let bgcolor = bgcolor { mergedAttributes["bgcolor"] = bgcolor }
  684|       |    if let content = content { mergedAttributes["content"] = content }
  685|       |    if let noshade = noshade { mergedAttributes["noshade"] = noshade }
  686|       |    if let summary = summary { mergedAttributes["summary"] = summary }
  687|       |    if let headers = headers { mergedAttributes["headers"] = headers }
  688|       |    if let onselect = onselect { mergedAttributes["onselect"] = onselect }
  689|       |    if let readonly = readonly { mergedAttributes["readonly"] = readonly }
  690|       |    if let tabindex = tabindex { mergedAttributes["tabindex"] = tabindex }
  691|       |    if let onchange = onchange { mergedAttributes["onchange"] = onchange }
  692|       |    if let noresize = noresize { mergedAttributes["noresize"] = noresize }
  693|       |    if let disabled = disabled { mergedAttributes["disabled"] = disabled }
  694|       |    if let longdesc = longdesc { mergedAttributes["longdesc"] = longdesc }
  695|       |    if let codebase = codebase { mergedAttributes["codebase"] = codebase }
  696|       |    if let language = language { mergedAttributes["language"] = language }
  697|       |    if let datetime = datetime { mergedAttributes["datetime"] = datetime }
  698|       |    if let selected = selected { mergedAttributes["selected"] = selected }
  699|       |    if let hreflang = hreflang { mergedAttributes["hreflang"] = hreflang }
  700|       |    if let onsubmit = onsubmit { mergedAttributes["onsubmit"] = onsubmit }
  701|       |    if let multiple = multiple { mergedAttributes["multiple"] = multiple }
  702|       |    if let onunload = onunload { mergedAttributes["onunload"] = onunload }
  703|       |    if let codetype = codetype { mergedAttributes["codetype"] = codetype }
  704|       |    if let scrolling = scrolling { mergedAttributes["scrolling"] = scrolling }
  705|       |    if let onkeydown = onkeydown { mergedAttributes["onkeydown"] = onkeydown }
  706|       |    if let maxlength = maxlength { mergedAttributes["maxlength"] = maxlength }
  707|       |    if let valuetype = valuetype { mergedAttributes["valuetype"] = valuetype }
  708|       |    if let accesskey = accesskey { mergedAttributes["accesskey"] = accesskey }
  709|       |    if let onmouseup = onmouseup { mergedAttributes["onmouseup"] = onmouseup }
  710|       |    if let onkeypress = onkeypress { mergedAttributes["onkeypress"] = onkeypress }
  711|       |    if let ondblclick = ondblclick { mergedAttributes["ondblclick"] = ondblclick }
  712|       |    if let onmouseout = onmouseout { mergedAttributes["onmouseout"] = onmouseout }
  713|       |    if let httpEquiv = httpEquiv { mergedAttributes["http-equiv"] = httpEquiv }
  714|       |    if let background = background { mergedAttributes["background"] = background }
  715|       |    if let onmousemove = onmousemove { mergedAttributes["onmousemove"] = onmousemove }
  716|       |    if let onmouseover = onmouseover { mergedAttributes["onmouseover"] = onmouseover }
  717|       |    if let cellpadding = cellpadding { mergedAttributes["cellpadding"] = cellpadding }
  718|       |    if let onmousedown = onmousedown { mergedAttributes["onmousedown"] = onmousedown }
  719|       |    if let frameborder = frameborder { mergedAttributes["frameborder"] = frameborder }
  720|       |    if let marginwidth = marginwidth { mergedAttributes["marginwidth"] = marginwidth }
  721|       |    if let cellspacing = cellspacing { mergedAttributes["cellspacing"] = cellspacing }
  722|       |    if let placeholder = placeholder { mergedAttributes["placeholder"] = placeholder }
  723|       |    if let marginheight = marginheight { mergedAttributes["marginheight"] = marginheight }
  724|       |    if let acceptCharset = acceptCharset { mergedAttributes["accept-charset"] = acceptCharset }
  725|       |    
  726|       |    for item in attrs.enumerated() {
  727|       |        mergedAttributes.updateValue(item.element.1, forKey: item.element.0)
  728|       |    }
  729|       |    
  730|      0|    output = output + mergedAttributes.reduce("") { result, item in
  731|      0|        if let value = item.value {
  732|      0|            return result + " \(item.key)=\"\(value)\""
  733|      0|        } else {
  734|      0|            return result
  735|      0|        }
  736|      0|    }
  737|       |    
  738|       |    if let inner = inner {
  739|       |        ScopesBuffer[Process.tid] = output + ">" + (inner) + "</" + node + ">"
  740|       |    } else {
  741|       |        let current = ScopesBuffer[Process.tid]  ?? ""
  742|       |        ScopesBuffer[Process.tid] = output + ">" + current + "</" + node + ">"
  743|       |    }
  744|       |    
  745|       |    // Pop the attributes.
  746|       |    
  747|       |    idd = stackid
  748|       |    dir = stackdir
  749|       |    rel = stackrel
  750|       |    rev = stackrev
  751|       |    alt = stackalt
  752|       |    forr = stackfor
  753|       |    src = stacksrc
  754|       |    type = stacktype
  755|       |    href = stackhref
  756|       |    text = stacktext
  757|       |    abbr = stackabbr
  758|       |    size = stacksize
  759|       |    face = stackface
  760|       |    char = stackchar
  761|       |    cite = stackcite
  762|       |    span = stackspan
  763|       |    data = stackdata
  764|       |    axis = stackaxis
  765|       |    Name = stackName
  766|       |    name = stackname
  767|       |    code = stackcode
  768|       |    link = stacklink
  769|       |    lang = stacklang
  770|       |    cols = stackcols
  771|       |    rows = stackrows
  772|       |    ismap = stackismap
  773|       |    shape = stackshape
  774|       |    style = stackstyle
  775|       |    alink = stackalink
  776|       |    width = stackwidth
  777|       |    rules = stackrules
  778|       |    align = stackalign
  779|       |    frame = stackframe
  780|       |    vlink = stackvlink
  781|       |    deferr = stackdefer
  782|       |    color = stackcolor
  783|       |    media = stackmedia
  784|       |    title = stacktitle
  785|       |    scope = stackscope
  786|       |    classs = stackclass
  787|       |    value = stackvalue
  788|       |    clear = stackclear
  789|       |    start = stackstart
  790|       |    label = stacklabel
  791|       |    action = stackaction
  792|       |    height = stackheight
  793|       |    method = stackmethod
  794|       |    acceptt = stackaccept
  795|       |    object = stackobject
  796|       |    scheme = stackscheme
  797|       |    coords = stackcoords
  798|       |    usemap = stackusemap
  799|       |    onblur = stackonblur
  800|       |    nohref = stacknohref
  801|       |    nowrap = stacknowrap
  802|       |    hspace = stackhspace
  803|       |    border = stackborder
  804|       |    valign = stackvalign
  805|       |    vspace = stackvspace
  806|       |    onload = stackonload
  807|       |    target = stacktarget
  808|       |    prompt = stackprompt
  809|       |    onfocus = stackonfocus
  810|       |    enctype = stackenctype
  811|       |    onclick = stackonclick
  812|       |    onkeyup = stackonkeyup
  813|       |    profile = stackprofile
  814|       |    version = stackversion
  815|       |    onreset = stackonreset
  816|       |    charset = stackcharset
  817|       |    standby = stackstandby
  818|       |    colspan = stackcolspan
  819|       |    charoff = stackcharoff
  820|       |    classid = stackclassid
  821|       |    compact = stackcompact
  822|       |    declare = stackdeclare
  823|       |    rowspan = stackrowspan
  824|       |    checked = stackchecked
  825|       |    archive = stackarchive
  826|       |    bgcolor = stackbgcolor
  827|       |    content = stackcontent
  828|       |    noshade = stacknoshade
  829|       |    summary = stacksummary
  830|       |    headers = stackheaders
  831|       |    onselect = stackonselect
  832|       |    readonly = stackreadonly
  833|       |    tabindex = stacktabindex
  834|       |    onchange = stackonchange
  835|       |    noresize = stacknoresize
  836|       |    disabled = stackdisabled
  837|       |    longdesc = stacklongdesc
  838|       |    codebase = stackcodebase
  839|       |    language = stacklanguage
  840|       |    datetime = stackdatetime
  841|       |    selected = stackselected
  842|       |    hreflang = stackhreflang
  843|       |    onsubmit = stackonsubmit
  844|       |    multiple = stackmultiple
  845|       |    onunload = stackonunload
  846|       |    codetype = stackcodetype
  847|       |    scrolling = stackscrolling
  848|       |    onkeydown = stackonkeydown
  849|       |    maxlength = stackmaxlength
  850|       |    valuetype = stackvaluetype
  851|       |    accesskey = stackaccesskey
  852|       |    onmouseup = stackonmouseup
  853|       |    onkeypress = stackonkeypress
  854|       |    ondblclick = stackondblclick
  855|       |    onmouseout = stackonmouseout
  856|       |    httpEquiv = stackhttpEquiv
  857|       |    background = stackbackground
  858|       |    onmousemove = stackonmousemove
  859|       |    onmouseover = stackonmouseover
  860|       |    cellpadding = stackcellpadding
  861|       |    onmousedown = stackonmousedown
  862|       |    frameborder = stackframeborder
  863|       |    placeholder = stackplaceholder
  864|       |    marginwidth = stackmarginwidth
  865|       |    cellspacing = stackcellspacing
  866|       |    marginheight = stackmarginheight
  867|       |    acceptCharset = stackacceptCharset
  868|       |    
  869|       |    inner = stackinner
  870|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Socket+File.swift:
    1|       |//
    2|       |//  Socket+File.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Created by Damian Kolakowski on 13/07/16.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |#if os(iOS) || os(tvOS) || os (Linux)
   11|       |    struct sf_hdtr { }
   12|       |    
   13|      0|    private func sendfileImpl(_ source: UnsafeMutablePointer<FILE>, _ target: Int32, _: off_t, _: UnsafeMutablePointer<off_t>, _: UnsafeMutablePointer<sf_hdtr>, _: Int32) -> Int32 {
   14|      0|        var buffer = [UInt8](repeating: 0, count: 1024)
   15|      0|        while true {
   16|      0|            let readResult = fread(&buffer, 1, buffer.count, source)
   17|      0|            guard readResult > 0 else {
   18|      0|                return Int32(readResult)
   19|      0|            }
   20|      0|            var writeCounter = 0
   21|      0|            while writeCounter < readResult {
   22|      0|                #if os(Linux)
   23|      0|                    let writeResult = send(target, &buffer + writeCounter, readResult - writeCounter, Int32(MSG_NOSIGNAL))
   24|      0|                #else
   25|      0|                    let writeResult = write(target, &buffer + writeCounter, readResult - writeCounter)
   26|      0|                #endif
   27|      0|                guard writeResult > 0 else {
   28|      0|                    return Int32(writeResult)
   29|      0|                }
   30|      0|                writeCounter = writeCounter + writeResult
   31|      0|            }
   32|      0|        }
   33|      0|    }
   34|       |#endif
   35|       |
   36|       |extension Socket {
   37|       |    
   38|      0|    public func writeFile(_ file: String.File) throws -> Void {
   39|      0|        var offset: off_t = 0
   40|      0|        var sf: sf_hdtr = sf_hdtr()
   41|      0|        
   42|      0|        #if os(iOS) || os(tvOS) || os (Linux)
   43|      0|        let result = sendfileImpl(file.pointer, self.socketFileDescriptor, 0, &offset, &sf, 0)
   44|      0|        #else
   45|      0|        let result = sendfile(fileno(file.pointer), self.socketFileDescriptor, 0, &offset, &sf, 0)
   46|      0|        #endif
   47|      0|        
   48|      0|        if result == -1 {
   49|      0|            throw SocketError.writeFailed("sendfile: " + Errno.description())
   50|      0|        }
   51|      0|    }
   52|       |    
   53|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Socket+Server.swift:
    1|       |//
    2|       |//  Socket+Server.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Created by Damian Kolakowski on 13/07/16.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |extension Socket {
   11|       |
   12|       |    /// - Parameters:
   13|       |    ///   - listenAddress: String representation of the address the socket should accept
   14|       |    ///       connections from. It should be in IPv4 format if forceIPv4 == true,
   15|       |    ///       otherwise - in IPv6.
   16|      0|    public class func tcpSocketForListen(_ port: in_port_t, _ forceIPv4: Bool = false, _ maxPendingConnection: Int32 = SOMAXCONN, _ listenAddress: String? = nil) throws -> Socket {
   17|      0|
   18|      0|        #if os(Linux)
   19|      0|            let socketFileDescriptor = socket(forceIPv4 ? AF_INET : AF_INET6, Int32(SOCK_STREAM.rawValue), 0)
   20|      0|        #else
   21|      0|            let socketFileDescriptor = socket(forceIPv4 ? AF_INET : AF_INET6, SOCK_STREAM, 0)
   22|      0|        #endif
   23|      0|
   24|      0|        if socketFileDescriptor == -1 {
   25|      0|            throw SocketError.socketCreationFailed(Errno.description())
   26|      0|        }
   27|      0|
   28|      0|        var value: Int32 = 1
   29|      0|        if setsockopt(socketFileDescriptor, SOL_SOCKET, SO_REUSEADDR, &value, socklen_t(MemoryLayout<Int32>.size)) == -1 {
   30|      0|            let details = Errno.description()
   31|      0|            Socket.close(socketFileDescriptor)
   32|      0|            throw SocketError.socketSettingReUseAddrFailed(details)
   33|      0|        }
   34|      0|        Socket.setNoSigPipe(socketFileDescriptor)
   35|      0|
   36|      0|        var bindResult: Int32 = -1
   37|      0|        if forceIPv4 {
   38|      0|            #if os(Linux)
   39|      0|            var addr = sockaddr_in(
   40|      0|                sin_family: sa_family_t(AF_INET),
   41|      0|                sin_port: port.bigEndian,
   42|      0|                sin_addr: in_addr(s_addr: in_addr_t(0)),
   43|      0|                sin_zero:(0, 0, 0, 0, 0, 0, 0, 0))
   44|      0|            #else
   45|      0|            var addr = sockaddr_in(
   46|      0|                sin_len: UInt8(MemoryLayout<sockaddr_in>.stride),
   47|      0|                sin_family: UInt8(AF_INET),
   48|      0|                sin_port: port.bigEndian,
   49|      0|                sin_addr: in_addr(s_addr: in_addr_t(0)),
   50|      0|                sin_zero:(0, 0, 0, 0, 0, 0, 0, 0))
   51|      0|            #endif
   52|      0|            if let address = listenAddress {
   53|      0|              if address.withCString({ cstring in inet_pton(AF_INET, cstring, &addr.sin_addr) }) == 1 {
   54|      0|                // print("\(address) is converted to \(addr.sin_addr).")
   55|      0|              } else {
   56|      0|                // print("\(address) is not converted.")
   57|      0|              }
   58|      0|            }
   59|      0|            bindResult = withUnsafePointer(to: &addr) {
   60|      0|                bind(socketFileDescriptor, UnsafePointer<sockaddr>(OpaquePointer($0)), socklen_t(MemoryLayout<sockaddr_in>.size))
   61|      0|            }
   62|      0|        } else {
   63|      0|            #if os(Linux)
   64|      0|            var addr = sockaddr_in6(
   65|      0|                sin6_family: sa_family_t(AF_INET6),
   66|      0|                sin6_port: port.bigEndian,
   67|      0|                sin6_flowinfo: 0,
   68|      0|                sin6_addr: in6addr_any,
   69|      0|                sin6_scope_id: 0)
   70|      0|            #else
   71|      0|            var addr = sockaddr_in6(
   72|      0|                sin6_len: UInt8(MemoryLayout<sockaddr_in6>.stride),
   73|      0|                sin6_family: UInt8(AF_INET6),
   74|      0|                sin6_port: port.bigEndian,
   75|      0|                sin6_flowinfo: 0,
   76|      0|                sin6_addr: in6addr_any,
   77|      0|                sin6_scope_id: 0)
   78|      0|            #endif
   79|      0|            if let address = listenAddress {
   80|      0|              if address.withCString({ cstring in inet_pton(AF_INET6, cstring, &addr.sin6_addr) }) == 1 {
   81|      0|                //print("\(address) is converted to \(addr.sin6_addr).")
   82|      0|              } else {
   83|      0|                //print("\(address) is not converted.")
   84|      0|              }
   85|      0|            }
   86|      0|            bindResult = withUnsafePointer(to: &addr) {
   87|      0|                bind(socketFileDescriptor, UnsafePointer<sockaddr>(OpaquePointer($0)), socklen_t(MemoryLayout<sockaddr_in6>.size))
   88|      0|            }
   89|      0|        }
   90|      0|
   91|      0|        if bindResult == -1 {
   92|      0|            let details = Errno.description()
   93|      0|            Socket.close(socketFileDescriptor)
   94|      0|            throw SocketError.bindFailed(details)
   95|      0|        }
   96|      0|
   97|      0|        if listen(socketFileDescriptor, maxPendingConnection) == -1 {
   98|      0|            let details = Errno.description()
   99|      0|            Socket.close(socketFileDescriptor)
  100|      0|            throw SocketError.listenFailed(details)
  101|      0|        }
  102|      0|        return Socket(socketFileDescriptor: socketFileDescriptor)
  103|      0|    }
  104|       |    
  105|      0|    public func acceptClientSocket() throws -> Socket {
  106|      0|        var addr = sockaddr()
  107|      0|        var len: socklen_t = 0
  108|      0|        let clientSocket = accept(self.socketFileDescriptor, &addr, &len)
  109|      0|        if clientSocket == -1 {
  110|      0|            throw SocketError.acceptFailed(Errno.description())
  111|      0|        }
  112|      0|        Socket.setNoSigPipe(clientSocket)
  113|      0|        return Socket(socketFileDescriptor: clientSocket)
  114|      0|    }
  115|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/Socket.swift:
    1|       |//
    2|       |//  Socket.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |public enum SocketError: Error {
   12|       |    case socketCreationFailed(String)
   13|       |    case socketSettingReUseAddrFailed(String)
   14|       |    case bindFailed(String)
   15|       |    case listenFailed(String)
   16|       |    case writeFailed(String)
   17|       |    case getPeerNameFailed(String)
   18|       |    case convertingPeerNameFailed
   19|       |    case getNameInfoFailed(String)
   20|       |    case acceptFailed(String)
   21|       |    case recvFailed(String)
   22|       |    case getSockNameFailed(String)
   23|       |}
   24|       |
   25|       |open class Socket: Hashable, Equatable {
   26|       |        
   27|       |    let socketFileDescriptor: Int32
   28|       |    private var shutdown = false
   29|       |
   30|       |    
   31|      0|    public init(socketFileDescriptor: Int32) {
   32|      0|        self.socketFileDescriptor = socketFileDescriptor
   33|      0|    }
   34|       |    
   35|      0|    deinit {
   36|      0|        close()
   37|      0|    }
   38|       |    
   39|      0|    public var hashValue: Int { return Int(self.socketFileDescriptor) }
   40|       |    
   41|      0|    public func close() {
   42|      0|        if shutdown {
   43|      0|            return
   44|      0|        }
   45|      0|        shutdown = true
   46|      0|        Socket.close(self.socketFileDescriptor)
   47|      0|    }
   48|       |    
   49|      0|    public func port() throws -> in_port_t {
   50|      0|        var addr = sockaddr_in()
   51|      0|        return try withUnsafePointer(to: &addr) { pointer in
   52|      0|            var len = socklen_t(MemoryLayout<sockaddr_in>.size)
   53|      0|            if getsockname(socketFileDescriptor, UnsafeMutablePointer(OpaquePointer(pointer)), &len) != 0 {
   54|      0|                throw SocketError.getSockNameFailed(Errno.description())
   55|      0|            }
   56|      0|            let sin_port = pointer.pointee.sin_port
   57|      0|            #if os(Linux)
   58|      0|                return ntohs(sin_port)
   59|      0|            #else
   60|      0|                return Int(OSHostByteOrder()) != OSLittleEndian ? sin_port.littleEndian : sin_port.bigEndian
   61|      0|            #endif
   62|      0|        }
   63|      0|    }
   64|       |    
   65|      0|    public func isIPv4() throws -> Bool {
   66|      0|        var addr = sockaddr_in()
   67|      0|        return try withUnsafePointer(to: &addr) { pointer in
   68|      0|            var len = socklen_t(MemoryLayout<sockaddr_in>.size)
   69|      0|            if getsockname(socketFileDescriptor, UnsafeMutablePointer(OpaquePointer(pointer)), &len) != 0 {
   70|      0|                throw SocketError.getSockNameFailed(Errno.description())
   71|      0|            }
   72|      0|            return Int32(pointer.pointee.sin_family) == AF_INET
   73|      0|        }
   74|      0|    }
   75|       |    
   76|      0|    public func writeUTF8(_ string: String) throws {
   77|      0|        try writeUInt8(ArraySlice(string.utf8))
   78|      0|    }
   79|       |    
   80|      0|    public func writeUInt8(_ data: [UInt8]) throws {
   81|      0|        try writeUInt8(ArraySlice(data))
   82|      0|    }
   83|       |    
   84|      0|    public func writeUInt8(_ data: ArraySlice<UInt8>) throws {
   85|      0|        try data.withUnsafeBufferPointer {
   86|      0|            try writeBuffer($0.baseAddress!, length: data.count)
   87|      0|        }
   88|      0|    }
   89|       |
   90|      0|    public func writeData(_ data: NSData) throws {
   91|      0|        try writeBuffer(data.bytes, length: data.length)
   92|      0|    }
   93|       |    
   94|      0|    public func writeData(_ data: Data) throws {
   95|      0|        try data.withUnsafeBytes { (pointer: UnsafePointer<UInt8>) -> Void in
   96|      0|            try self.writeBuffer(pointer, length: data.count)
   97|      0|        }
   98|      0|    }
   99|       |
  100|      0|    private func writeBuffer(_ pointer: UnsafeRawPointer, length: Int) throws {
  101|      0|        var sent = 0
  102|      0|        while sent < length {
  103|      0|            #if os(Linux)
  104|      0|                let s = send(self.socketFileDescriptor, pointer + sent, Int(length - sent), Int32(MSG_NOSIGNAL))
  105|      0|            #else
  106|      0|                let s = write(self.socketFileDescriptor, pointer + sent, Int(length - sent))
  107|      0|            #endif
  108|      0|            if s <= 0 {
  109|      0|                throw SocketError.writeFailed(Errno.description())
  110|      0|            }
  111|      0|            sent += s
  112|      0|        }
  113|      0|    }
  114|       |    
  115|      0|    open func read() throws -> UInt8 {
  116|      0|        var buffer = [UInt8](repeating: 0, count: 1)
  117|      0|        #if os(Linux)
  118|      0|            let next = recv(self.socketFileDescriptor as Int32, &buffer, Int(buffer.count), Int32(MSG_NOSIGNAL))
  119|      0|        #else
  120|      0|            let next = recv(self.socketFileDescriptor as Int32, &buffer, Int(buffer.count), 0)
  121|      0|        #endif
  122|      0|        if next <= 0 {
  123|      0|            throw SocketError.recvFailed(Errno.description())
  124|      0|        }
  125|      0|        return buffer[0]
  126|      0|    }
  127|       |    
  128|       |    private static let CR = UInt8(13)
  129|       |    private static let NL = UInt8(10)
  130|       |    
  131|      0|    public func readLine() throws -> String {
  132|      0|        var characters: String = ""
  133|      0|        var n: UInt8 = 0
  134|      0|        repeat {
  135|      0|            n = try self.read()
  136|      0|            if n > Socket.CR { characters.append(Character(UnicodeScalar(n))) }
  137|      0|        } while n != Socket.NL
  138|      0|        return characters
  139|      0|    }
  140|       |    
  141|      0|    public func peername() throws -> String {
  142|      0|        var addr = sockaddr(), len: socklen_t = socklen_t(MemoryLayout<sockaddr>.size)
  143|      0|        if getpeername(self.socketFileDescriptor, &addr, &len) != 0 {
  144|      0|            throw SocketError.getPeerNameFailed(Errno.description())
  145|      0|        }
  146|      0|        var hostBuffer = [CChar](repeating: 0, count: Int(NI_MAXHOST))
  147|      0|        if getnameinfo(&addr, len, &hostBuffer, socklen_t(hostBuffer.count), nil, 0, NI_NUMERICHOST) != 0 {
  148|      0|            throw SocketError.getNameInfoFailed(Errno.description())
  149|      0|        }
  150|      0|        return String(cString: hostBuffer)
  151|      0|    }
  152|       |    
  153|      0|    public class func setNoSigPipe(_ socket: Int32) {
  154|      0|        #if os(Linux)
  155|      0|            // There is no SO_NOSIGPIPE in Linux (nor some other systems). You can instead use the MSG_NOSIGNAL flag when calling send(),
  156|      0|            // or use signal(SIGPIPE, SIG_IGN) to make your entire application ignore SIGPIPE.
  157|      0|        #else
  158|      0|            // Prevents crashes when blocking calls are pending and the app is paused ( via Home button ).
  159|      0|            var no_sig_pipe: Int32 = 1
  160|      0|            setsockopt(socket, SOL_SOCKET, SO_NOSIGPIPE, &no_sig_pipe, socklen_t(MemoryLayout<Int32>.size))
  161|      0|        #endif
  162|      0|    }
  163|       |    
  164|      0|    public class func close(_ socket: Int32) {
  165|      0|        #if os(Linux)
  166|      0|            let _ = Glibc.close(socket)
  167|      0|        #else
  168|      0|            let _ = Darwin.close(socket)
  169|      0|        #endif
  170|      0|    }
  171|       |}
  172|       |
  173|       |public func == (socket1: Socket, socket2: Socket) -> Bool {
  174|       |    return socket1.socketFileDescriptor == socket2.socketFileDescriptor
  175|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/String+BASE64.swift:
    1|       |//
    2|       |//  String+BASE64.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright © 2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |extension String {
   12|       |    
   13|       |    private static let CODES = [UInt8]("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".utf8)
   14|       |    
   15|      0|    public static func toBase64(_ data: [UInt8]) -> String? {
   16|      0|        
   17|      0|        // Based on: https://en.wikipedia.org/wiki/Base64#Sample_Implementation_in_Java
   18|      0|        
   19|      0|        var result = [UInt8]()
   20|      0|        var tmp: UInt8
   21|      0|        for index in stride(from: 0, to: data.count, by: 3) {
   22|      0|            let byte = data[index]
   23|      0|            tmp = (byte & 0xFC) >> 2;
   24|      0|            result.append(CODES[Int(tmp)])
   25|      0|            tmp = (byte & 0x03) << 4;
   26|      0|            if index + 1 < data.count {
   27|      0|                tmp |= (data[index + 1] & 0xF0) >> 4;
   28|      0|                result.append(CODES[Int(tmp)]);
   29|      0|                tmp = (data[index + 1] & 0x0F) << 2;
   30|      0|                if (index + 2 < data.count)  {
   31|      0|                    tmp |= (data[index + 2] & 0xC0) >> 6;
   32|      0|                    result.append(CODES[Int(tmp)]);
   33|      0|                    tmp = data[index + 2] & 0x3F;
   34|      0|                    result.append(CODES[Int(tmp)]);
   35|      0|                } else  {
   36|      0|                    result.append(CODES[Int(tmp)]);
   37|      0|                    result.append(contentsOf: [UInt8]("=".utf8));
   38|      0|                }
   39|      0|            } else {
   40|      0|                result.append(CODES[Int(tmp)]);
   41|      0|                result.append(contentsOf: [UInt8]("==".utf8));
   42|      0|            }
   43|      0|        }
   44|      0|        return String(bytes: result, encoding: .utf8)
   45|      0|    }
   46|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/String+File.swift:
    1|       |//
    2|       |//  String+File.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright © 2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |extension String {
   12|       |    
   13|       |    public enum FileError: Error {
   14|       |        case error(Int32)
   15|       |    }
   16|       |    
   17|       |    public class File {
   18|       |        
   19|       |        let pointer: UnsafeMutablePointer<FILE>
   20|       |        
   21|      0|        public init(_ pointer: UnsafeMutablePointer<FILE>) {
   22|      0|            self.pointer = pointer
   23|      0|        }
   24|       |        
   25|      0|        public func close() -> Void {
   26|      0|            fclose(pointer)
   27|      0|        }
   28|       |        
   29|      0|        public func seek(_ offset: Int) -> Bool {
   30|      0|            return (fseek(pointer, offset, SEEK_SET) == 0)
   31|      0|        }
   32|       |        
   33|      0|        public func read(_ data: inout [UInt8]) throws -> Int {
   34|      0|            if data.count <= 0 {
   35|      0|                return data.count
   36|      0|            }
   37|      0|            let count = fread(&data, 1, data.count, self.pointer)
   38|      0|            if count == data.count {
   39|      0|                return count
   40|      0|            }
   41|      0|            if feof(self.pointer) != 0 {
   42|      0|                return count
   43|      0|            }
   44|      0|            if ferror(self.pointer) != 0 {
   45|      0|                throw FileError.error(errno)
   46|      0|            }
   47|      0|            throw FileError.error(0)
   48|      0|        }
   49|       |        
   50|      0|        public func write(_ data: [UInt8]) throws -> Void {
   51|      0|            if data.count <= 0 {
   52|      0|                return
   53|      0|            }
   54|      0|            try data.withUnsafeBufferPointer {
   55|      0|                if fwrite($0.baseAddress, 1, data.count, self.pointer) != data.count {
   56|      0|                    throw FileError.error(errno)
   57|      0|                }
   58|      0|            }
   59|      0|        }
   60|       |        
   61|      0|        public static func currentWorkingDirectory() throws -> String {
   62|      0|            guard let path = getcwd(nil, 0) else {
   63|      0|                throw FileError.error(errno)
   64|      0|            }
   65|      0|            return String(cString: path)
   66|      0|        }
   67|       |    }
   68|       |    
   69|       |    public static var pathSeparator = "/"
   70|       |    
   71|      0|    public func openNewForWriting() throws -> File {
   72|      0|        return try openFileForMode(self, "wb")
   73|      0|    }
   74|       |    
   75|      0|    public func openForReading() throws -> File {
   76|      0|        return try openFileForMode(self, "rb")
   77|      0|    }
   78|       |    
   79|      0|    public func openForWritingAndReading() throws -> File {
   80|      0|        return try openFileForMode(self, "r+b")
   81|      0|    }
   82|       |    
   83|       |    public func openFileForMode(_ path: String, _ mode: String) throws -> File {
   84|      0|        guard let file = path.withCString({ pathPointer in mode.withCString({ fopen(pathPointer, $0) }) }) else {
   85|       |            throw FileError.error(errno)
   86|       |        }
   87|       |        return File(file)
   88|       |    }
   89|       |    
   90|      0|    public func exists() throws -> Bool {
   91|      0|        return try self.withStat {
   92|      0|            if let _ = $0 {
   93|      0|                return true
   94|      0|            }
   95|      0|            return false
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    public func directory() throws -> Bool {
  100|      0|        return try self.withStat {
  101|      0|            if let stat = $0 {
  102|      0|                return stat.st_mode & S_IFMT == S_IFDIR
  103|      0|            }
  104|      0|            return false
  105|      0|        }
  106|      0|    }
  107|       |    
  108|      0|    public func files() throws -> [String] {
  109|      0|        guard let dir = self.withCString({ opendir($0) }) else {
  110|      0|            throw FileError.error(errno)
  111|      0|        }
  112|      0|        defer { closedir(dir) }
  113|      0|        var results = [String]()
  114|      0|        while let ent = readdir(dir) {
  115|      0|            var name = ent.pointee.d_name
  116|      0|            let fileName = withUnsafePointer(to: &name) { (ptr) -> String? in
  117|      0|                #if os(Linux)
  118|      0|                  return String(validatingUTF8: ptr.withMemoryRebound(to: CChar.self, capacity: Int(ent.pointee.d_reclen), { (ptrc) -> [CChar] in
  119|      0|                    return [CChar](UnsafeBufferPointer(start: ptrc, count: 256))
  120|      0|                  }))
  121|      0|                #else
  122|      0|                    var buffer = ptr.withMemoryRebound(to: CChar.self, capacity: Int(ent.pointee.d_reclen), { (ptrc) -> [CChar] in
  123|      0|                      return [CChar](UnsafeBufferPointer(start: ptrc, count: Int(ent.pointee.d_namlen)))
  124|      0|                    })
  125|      0|                    buffer.append(0)
  126|      0|                    return String(validatingUTF8: buffer)
  127|      0|                #endif
  128|      0|            }
  129|      0|            if let fileName = fileName {
  130|      0|                results.append(fileName)
  131|      0|            }
  132|      0|        }
  133|      0|        return results
  134|      0|    }
  135|       |    
  136|       |    private func withStat<T>(_ closure: ((stat?) throws -> T)) throws -> T {
  137|      0|        return try self.withCString({
  138|      0|            var statBuffer = stat()
  139|      0|            if stat($0, &statBuffer) == 0 {
  140|      0|                return try closure(statBuffer)
  141|      0|            }
  142|      0|            if errno == ENOENT {
  143|      0|                return try closure(nil)
  144|      0|            }
  145|      0|            throw FileError.error(errno)
  146|      0|        })
  147|       |    }
  148|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/String+Misc.swift:
    1|       |//
    2|       |//  String+Misc.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright (c) 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |extension String {
   12|       |    
   13|      0|    public func unquote() -> String {
   14|      0|        var scalars = self.unicodeScalars;
   15|      0|        if scalars.first == "\"" && scalars.last == "\"" && scalars.count >= 2 {
   16|      0|            scalars.removeFirst();
   17|      0|            scalars.removeLast();
   18|      0|            return String(scalars)
   19|      0|        }
   20|      0|        return self
   21|      0|    }
   22|       |}
   23|       |
   24|       |extension UnicodeScalar {
   25|       |    
   26|      0|    public func asWhitespace() -> UInt8? {
   27|      0|        if self.value >= 9 && self.value <= 13 {
   28|      0|            return UInt8(self.value)
   29|      0|        }
   30|      0|        if self.value == 32 {
   31|      0|            return UInt8(self.value)
   32|      0|        }
   33|      0|        return nil
   34|      0|    }
   35|       |    
   36|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/String+SHA1.swift:
    1|       |//
    2|       |//  String+SHA1.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |public struct SHA1 {
   12|       |    
   13|      0|    public static func hash(_ input: [UInt8]) -> [UInt8] {
   14|      0|        
   15|      0|        // Alghorithm from: https://en.wikipedia.org/wiki/SHA-1
   16|      0|        
   17|      0|        var message = input
   18|      0|        
   19|      0|        var h0 = UInt32(littleEndian: 0x67452301)
   20|      0|        var h1 = UInt32(littleEndian: 0xEFCDAB89)
   21|      0|        var h2 = UInt32(littleEndian: 0x98BADCFE)
   22|      0|        var h3 = UInt32(littleEndian: 0x10325476)
   23|      0|        var h4 = UInt32(littleEndian: 0xC3D2E1F0)
   24|      0|        
   25|      0|        // ml = message length in bits (always a multiple of the number of bits in a character).
   26|      0|        
   27|      0|        let ml = UInt64(message.count * 8)
   28|      0|        
   29|      0|        // append the bit '1' to the message e.g. by adding 0x80 if message length is a multiple of 8 bits.
   30|      0|        
   31|      0|        message.append(0x80)
   32|      0|        
   33|      0|        // append 0 ≤ k < 512 bits '0', such that the resulting message length in bits is congruent to −64 ≡ 448 (mod 512)
   34|      0|        
   35|      0|        let padBytesCount = ( message.count + 8 ) % 64
   36|      0|        
   37|      0|        message.append(contentsOf: [UInt8](repeating: 0, count: 64 - padBytesCount))
   38|      0|        
   39|      0|        // append ml, in a 64-bit big-endian integer. Thus, the total length is a multiple of 512 bits.
   40|      0|        
   41|      0|        var mlBigEndian = ml.bigEndian
   42|      0|        withUnsafePointer(to: &mlBigEndian) {
   43|      0|            message.append(contentsOf: Array(UnsafeBufferPointer<UInt8>(start: UnsafePointer(OpaquePointer($0)), count: 8)))
   44|      0|        }
   45|      0|        
   46|      0|        // Process the message in successive 512-bit chunks ( 64 bytes chunks ):
   47|      0|        
   48|      0|        for chunkStart in 0..<message.count/64 {
   49|      0|            var words = [UInt32]()
   50|      0|            let chunk = message[chunkStart*64..<chunkStart*64+64]
   51|      0|            
   52|      0|            // break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15
   53|      0|            
   54|      0|            for i in 0...15 {
   55|      0|                let value = chunk.withUnsafeBufferPointer({ UnsafePointer<UInt32>(OpaquePointer($0.baseAddress! + (i*4))).pointee})
   56|      0|                words.append(value.bigEndian)
   57|      0|            }
   58|      0|            
   59|      0|            // Extend the sixteen 32-bit words into eighty 32-bit words:
   60|      0|            
   61|      0|            for i in 16...79 {
   62|      0|                let value: UInt32 = ((words[i-3]) ^ (words[i-8]) ^ (words[i-14]) ^ (words[i-16]))
   63|      0|                words.append(rotateLeft(value, 1))
   64|      0|            }
   65|      0|            
   66|      0|            // Initialize hash value for this chunk:
   67|      0|            
   68|      0|            var a = h0
   69|      0|            var b = h1
   70|      0|            var c = h2
   71|      0|            var d = h3
   72|      0|            var e = h4
   73|      0|            
   74|      0|            for i in 0..<80 {
   75|      0|                var f = UInt32(0)
   76|      0|                var k = UInt32(0)
   77|      0|                switch i {
   78|      0|                case 0...19:
   79|      0|                    f = (b & c) | ((~b) & d)
   80|      0|                    k = 0x5A827999
   81|      0|                case 20...39:
   82|      0|                    f = b ^ c ^ d
   83|      0|                    k = 0x6ED9EBA1
   84|      0|                case 40...59:
   85|      0|                    f = (b & c) | (b & d) | (c & d)
   86|      0|                    k = 0x8F1BBCDC
   87|      0|                case 60...79:
   88|      0|                    f = b ^ c ^ d
   89|      0|                    k = 0xCA62C1D6
   90|      0|                default: break
   91|      0|                }
   92|      0|                let temp = (rotateLeft(a, 5) &+ f &+ e &+ k &+ words[i]) & 0xFFFFFFFF
   93|      0|                e = d
   94|      0|                d = c
   95|      0|                c = rotateLeft(b, 30)
   96|      0|                b = a
   97|      0|                a = temp
   98|      0|            }
   99|      0|            
  100|      0|            // Add this chunk's hash to result so far:
  101|      0|            
  102|      0|            h0 = ( h0 &+ a ) & 0xFFFFFFFF
  103|      0|            h1 = ( h1 &+ b ) & 0xFFFFFFFF
  104|      0|            h2 = ( h2 &+ c ) & 0xFFFFFFFF
  105|      0|            h3 = ( h3 &+ d ) & 0xFFFFFFFF
  106|      0|            h4 = ( h4 &+ e ) & 0xFFFFFFFF
  107|      0|        }
  108|      0|        
  109|      0|        // Produce the final hash value (big-endian) as a 160 bit number:
  110|      0|        
  111|      0|        var digest = [UInt8]()
  112|      0|        
  113|      0|        [h0, h1, h2, h3, h4].forEach { value in
  114|      0|            var bigEndianVersion = value.bigEndian
  115|      0|            withUnsafePointer(to: &bigEndianVersion) {
  116|      0|                digest.append(contentsOf: Array(UnsafeBufferPointer<UInt8>(start: UnsafePointer(OpaquePointer($0)), count: 4)))
  117|      0|            }
  118|      0|        }
  119|      0|        
  120|      0|        return digest
  121|      0|    }
  122|       |    
  123|       |    private static func rotateLeft(_ v: UInt32, _ n: UInt32) -> UInt32 {
  124|       |        return ((v << n) & 0xFFFFFFFF) | (v >> (32 - n))
  125|       |    }
  126|       |}
  127|       |
  128|       |extension String {
  129|       |    
  130|      0|    public func sha1() -> [UInt8] {
  131|      0|        return SHA1.hash([UInt8](self.utf8))
  132|      0|    }
  133|       |    
  134|      0|    public func sha1() -> String {
  135|      0|        return self.sha1().reduce("") { $0 + String(format: "%02x", $1) }
  136|      0|    }
  137|       |}

/Users/deleted/Desktop/SB/01 - Prep/XCode/UIPasteboard/Pods/Swifter/Sources/WebSockets.swift:
    1|       |//
    2|       |//  HttpHandlers+WebSockets.swift
    3|       |//  Swifter
    4|       |//
    5|       |//  Copyright © 2014-2016 Damian Kołakowski. All rights reserved.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |@available(*, deprecated, message: "Use websocket(text:binary:pong:connected:disconnected:) instead.")
   11|       |public func websocket(_ text: @escaping (WebSocketSession, String) -> Void,
   12|       |                      _ binary: @escaping (WebSocketSession, [UInt8]) -> Void,
   13|      0|                      _ pong: @escaping (WebSocketSession, [UInt8]) -> Void) -> ((HttpRequest) -> HttpResponse) {
   14|      0|    return websocket(text: text, binary: binary, pong: pong)
   15|      0|}
   16|       |
   17|       |public func websocket(
   18|       |    text: ((WebSocketSession, String) -> Void)? = nil,
   19|       |    binary: ((WebSocketSession, [UInt8]) -> Void)? = nil,
   20|       |    pong: ((WebSocketSession, [UInt8]) -> Void)? = nil,
   21|       |    connected: ((WebSocketSession) -> Void)? = nil,
   22|       |    disconnected: ((WebSocketSession) -> Void)? = nil) -> ((HttpRequest) -> HttpResponse) {
   23|      0|    return { r in
   24|      0|        guard r.hasTokenForHeader("upgrade", token: "websocket") else {
   25|      0|            return .badRequest(.text("Invalid value of 'Upgrade' header: \(r.headers["upgrade"] ?? "unknown")"))
   26|      0|        }
   27|      0|        guard r.hasTokenForHeader("connection", token: "upgrade") else {
   28|      0|            return .badRequest(.text("Invalid value of 'Connection' header: \(r.headers["connection"] ?? "unknown")"))
   29|      0|        }
   30|      0|        guard let secWebSocketKey = r.headers["sec-websocket-key"] else {
   31|      0|            return .badRequest(.text("Invalid value of 'Sec-Websocket-Key' header: \(r.headers["sec-websocket-key"] ?? "unknown")"))
   32|      0|        }
   33|      0|        let protocolSessionClosure: ((Socket) -> Void) = { socket in
   34|      0|            let session = WebSocketSession(socket)
   35|      0|            var fragmentedOpCode = WebSocketSession.OpCode.close
   36|      0|            var payload = [UInt8]() // Used for fragmented frames.
   37|      0|            
   38|      0|            func handleTextPayload(_ frame: WebSocketSession.Frame) throws {
   39|      0|                if let handleText = text {
   40|      0|                    if frame.fin {
   41|      0|                        if payload.count > 0 {
   42|      0|                            throw WebSocketSession.WsError.protocolError("Continuing fragmented frame cannot have an operation code.")
   43|      0|                        }
   44|      0|                        var textFramePayload = frame.payload.map { Int8(bitPattern: $0) }
   45|      0|                        textFramePayload.append(0)
   46|      0|                        if let text = String(validatingUTF8: textFramePayload) {
   47|      0|                            handleText(session, text)
   48|      0|                        } else {
   49|      0|                            throw WebSocketSession.WsError.invalidUTF8("")
   50|      0|                        }
   51|      0|                    } else {
   52|      0|                        payload.append(contentsOf: frame.payload)
   53|      0|                        fragmentedOpCode = .text
   54|      0|                    }
   55|      0|                }
   56|      0|            }
   57|      0|            
   58|      0|            func handleBinaryPayload(_ frame: WebSocketSession.Frame) throws {
   59|      0|                if let handleBinary = binary {
   60|      0|                    if frame.fin {
   61|      0|                        if payload.count > 0 {
   62|      0|                            throw WebSocketSession.WsError.protocolError("Continuing fragmented frame cannot have an operation code.")
   63|      0|                        }
   64|      0|                        handleBinary(session, frame.payload)
   65|      0|                    } else {
   66|      0|                        payload.append(contentsOf: frame.payload)
   67|      0|                        fragmentedOpCode = .binary
   68|      0|                    }
   69|      0|                }
   70|      0|            }
   71|      0|            
   72|      0|            func handleOperationCode(_ frame: WebSocketSession.Frame) throws {
   73|      0|                switch frame.opcode {
   74|      0|                case .continue:
   75|      0|                    // There is no message to continue, failed immediatelly.
   76|      0|                    if fragmentedOpCode == .close {
   77|      0|                        socket.close()
   78|      0|                    }
   79|      0|                    frame.opcode = fragmentedOpCode
   80|      0|                    if frame.fin {
   81|      0|                        payload.append(contentsOf: frame.payload)
   82|      0|                        frame.payload = payload
   83|      0|                        // Clean the buffer.
   84|      0|                        payload = []
   85|      0|                        // Reset the OpCode.
   86|      0|                        fragmentedOpCode = WebSocketSession.OpCode.close
   87|      0|                    }
   88|      0|                    try handleOperationCode(frame)
   89|      0|                case .text:
   90|      0|                    try handleTextPayload(frame)
   91|      0|                case .binary:
   92|      0|                    try handleBinaryPayload(frame)
   93|      0|                case .close:
   94|      0|                    throw WebSocketSession.Control.close
   95|      0|                case .ping:
   96|      0|                    if frame.payload.count > 125 {
   97|      0|                        throw WebSocketSession.WsError.protocolError("Payload gretter than 125 octets.")
   98|      0|                    } else {
   99|      0|                        session.writeFrame(ArraySlice(frame.payload), .pong)
  100|      0|                    }
  101|      0|                case .pong:
  102|      0|                    if let handlePong = pong {
  103|      0|                       handlePong(session, frame.payload)
  104|      0|                    }
  105|      0|                    break
  106|      0|                }
  107|      0|            }
  108|      0|            
  109|      0|            func read() throws {
  110|      0|                while true {
  111|      0|                    let frame = try session.readFrame()
  112|      0|                    try handleOperationCode(frame)
  113|      0|                }
  114|      0|            }
  115|      0|            
  116|      0|            connected?(session)
  117|      0|            
  118|      0|            do {
  119|      0|                try read()
  120|      0|            } catch let error {
  121|      0|                switch error {
  122|      0|                case WebSocketSession.Control.close:
  123|      0|                    // Normal close
  124|      0|                    break
  125|      0|                case WebSocketSession.WsError.unknownOpCode:
  126|      0|                    print("Unknown Op Code: \(error)")
  127|      0|                case WebSocketSession.WsError.unMaskedFrame:
  128|      0|                    print("Unmasked frame: \(error)")
  129|      0|                case WebSocketSession.WsError.invalidUTF8:
  130|      0|                    print("Invalid UTF8 character: \(error)")
  131|      0|                case WebSocketSession.WsError.protocolError:
  132|      0|                    print("Protocol error: \(error)")
  133|      0|                default:
  134|      0|                    print("Unkown error \(error)")
  135|      0|                }
  136|      0|                // If an error occurs, send the close handshake.
  137|      0|                session.writeCloseFrame()
  138|      0|            }
  139|      0|            
  140|      0|            disconnected?(session)
  141|      0|        }
  142|      0|        guard let secWebSocketAccept = String.toBase64((secWebSocketKey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").sha1()) else {
  143|      0|            return HttpResponse.internalServerError
  144|      0|        }
  145|      0|        let headers = ["Upgrade": "WebSocket", "Connection": "Upgrade", "Sec-WebSocket-Accept": secWebSocketAccept]
  146|      0|        return HttpResponse.switchProtocols(headers, protocolSessionClosure)
  147|      0|    }
  148|       |}
  149|       |
  150|       |public class WebSocketSession: Hashable, Equatable  {
  151|       |    
  152|       |    public enum WsError: Error { case unknownOpCode(String), unMaskedFrame(String), protocolError(String), invalidUTF8(String) }
  153|       |    public enum OpCode: UInt8 { case `continue` = 0x00, close = 0x08, ping = 0x09, pong = 0x0A, text = 0x01, binary = 0x02 }
  154|       |    public enum Control: Error { case close }
  155|       |    
  156|       |    public class Frame {
  157|       |        public var opcode = OpCode.close
  158|       |        public var fin = false
  159|       |        public var rsv1: UInt8 = 0
  160|       |        public var rsv2: UInt8 = 0
  161|       |        public var rsv3: UInt8 = 0
  162|       |        public var payload = [UInt8]()
  163|       |    }
  164|       |
  165|       |    public let socket: Socket
  166|       |    
  167|      0|    public init(_ socket: Socket) {
  168|      0|        self.socket = socket
  169|      0|    }
  170|       |    
  171|      0|    deinit {
  172|      0|        writeCloseFrame()
  173|      0|        socket.close()
  174|      0|    }
  175|       |    
  176|      0|    public func writeText(_ text: String) -> Void {
  177|      0|        self.writeFrame(ArraySlice(text.utf8), OpCode.text)
  178|      0|    }
  179|       |
  180|      0|    public func writeBinary(_ binary: [UInt8]) -> Void {
  181|      0|        self.writeBinary(ArraySlice(binary))
  182|      0|    }
  183|       |    
  184|      0|    public func writeBinary(_ binary: ArraySlice<UInt8>) -> Void {
  185|      0|        self.writeFrame(binary, OpCode.binary)
  186|      0|    }
  187|       |    
  188|      0|    public func writeFrame(_ data: ArraySlice<UInt8>, _ op: OpCode, _ fin: Bool = true) {
  189|      0|        let finAndOpCode = UInt8(fin ? 0x80 : 0x00) | op.rawValue
  190|      0|        let maskAndLngth = encodeLengthAndMaskFlag(UInt64(data.count), false)
  191|      0|        do {
  192|      0|            try self.socket.writeUInt8([finAndOpCode])
  193|      0|            try self.socket.writeUInt8(maskAndLngth)
  194|      0|            try self.socket.writeUInt8(data)
  195|      0|        } catch {
  196|      0|            print(error)
  197|      0|        }
  198|      0|    }
  199|       |    
  200|      0|    public func writeCloseFrame() {
  201|      0|        writeFrame(ArraySlice("".utf8), .close)
  202|      0|    }
  203|       |    
  204|      0|    private func encodeLengthAndMaskFlag(_ len: UInt64, _ masked: Bool) -> [UInt8] {
  205|      0|        let encodedLngth = UInt8(masked ? 0x80 : 0x00)
  206|      0|        var encodedBytes = [UInt8]()
  207|      0|        switch len {
  208|      0|        case 0...125:
  209|      0|            encodedBytes.append(encodedLngth | UInt8(len));
  210|      0|        case 126...UInt64(UINT16_MAX):
  211|      0|            encodedBytes.append(encodedLngth | 0x7E);
  212|      0|            encodedBytes.append(UInt8(len >> 8 & 0xFF));
  213|      0|            encodedBytes.append(UInt8(len >> 0 & 0xFF));
  214|      0|        default:
  215|      0|            encodedBytes.append(encodedLngth | 0x7F);
  216|      0|            encodedBytes.append(UInt8(len >> 56 & 0xFF));
  217|      0|            encodedBytes.append(UInt8(len >> 48 & 0xFF));
  218|      0|            encodedBytes.append(UInt8(len >> 40 & 0xFF));
  219|      0|            encodedBytes.append(UInt8(len >> 32 & 0xFF));
  220|      0|            encodedBytes.append(UInt8(len >> 24 & 0xFF));
  221|      0|            encodedBytes.append(UInt8(len >> 16 & 0xFF));
  222|      0|            encodedBytes.append(UInt8(len >> 08 & 0xFF));
  223|      0|            encodedBytes.append(UInt8(len >> 00 & 0xFF));
  224|      0|        }
  225|      0|        return encodedBytes
  226|      0|    }
  227|       |    
  228|      0|    public func readFrame() throws -> Frame {
  229|      0|        let frm = Frame()
  230|      0|        let fst = try socket.read()
  231|      0|        frm.fin = fst & 0x80 != 0
  232|      0|        frm.rsv1 = fst & 0x40
  233|      0|        frm.rsv2 = fst & 0x20
  234|      0|        frm.rsv3 = fst & 0x10
  235|      0|        guard frm.rsv1 == 0 && frm.rsv2 == 0 && frm.rsv3 == 0
  236|      0|            else {
  237|      0|            throw WsError.protocolError("Reserved frame bit has not been negocitated.")
  238|      0|        }
  239|      0|        let opc = fst & 0x0F
  240|      0|        guard let opcode = OpCode(rawValue: opc) else {
  241|      0|            // "If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_."
  242|      0|            // http://tools.ietf.org/html/rfc6455#section-5.2 ( Page 29 )
  243|      0|            throw WsError.unknownOpCode("\(opc)")
  244|      0|        }
  245|      0|        if frm.fin == false {
  246|      0|            switch opcode {
  247|      0|            case .ping, .pong, .close:
  248|      0|                // Control frames must not be fragmented
  249|      0|                // https://tools.ietf.org/html/rfc6455#section-5.5 ( Page 35 )
  250|      0|                throw WsError.protocolError("Control frames must not be fragmented.")
  251|      0|            default:
  252|      0|                break
  253|      0|            }
  254|      0|        }
  255|      0|        frm.opcode = opcode
  256|      0|        let sec = try socket.read()
  257|      0|        let msk = sec & 0x80 != 0
  258|      0|        guard msk else {
  259|      0|            // "...a client MUST mask all frames that it sends to the server."
  260|      0|            // http://tools.ietf.org/html/rfc6455#section-5.1
  261|      0|            throw WsError.unMaskedFrame("A client must mask all frames that it sends to the server.")
  262|      0|        }
  263|      0|        var len = UInt64(sec & 0x7F)
  264|      0|        if len == 0x7E {
  265|      0|            let b0 = UInt64(try socket.read()) << 8
  266|      0|            let b1 = UInt64(try socket.read())
  267|      0|            len = UInt64(littleEndian: b0 | b1)
  268|      0|        } else if len == 0x7F {
  269|      0|            let b0 = UInt64(try socket.read()) << 54
  270|      0|            let b1 = UInt64(try socket.read()) << 48
  271|      0|            let b2 = UInt64(try socket.read()) << 40
  272|      0|            let b3 = UInt64(try socket.read()) << 32
  273|      0|            let b4 = UInt64(try socket.read()) << 24
  274|      0|            let b5 = UInt64(try socket.read()) << 16
  275|      0|            let b6 = UInt64(try socket.read()) << 8
  276|      0|            let b7 = UInt64(try socket.read())
  277|      0|            len = UInt64(littleEndian: b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7)
  278|      0|        }
  279|      0|        let mask = [try socket.read(), try socket.read(), try socket.read(), try socket.read()]
  280|      0|        for i in 0..<len {
  281|      0|            frm.payload.append(try socket.read() ^ mask[Int(i % 4)])
  282|      0|        }
  283|      0|        return frm
  284|      0|    }
  285|       |    
  286|       |    public var hashValue: Int {
  287|      0|        get {
  288|      0|            return socket.hashValue
  289|      0|        }
  290|       |    }
  291|       |}
  292|       |
  293|       |public func ==(webSocketSession1: WebSocketSession, webSocketSession2: WebSocketSession) -> Bool {
  294|       |    return webSocketSession1.socket == webSocketSession2.socket
  295|       |}

